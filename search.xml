<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端体系知识点（持续更新）]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%89%8D%E7%AB%AF%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JavaScript基础变量和类型 1.JavaScript规定了几种语言类型； 1ECMAScript的基本 闭包是什么 123在函数嵌套中外部函数是没有方式访问到内部函数中的变量和函数，当一个嵌套函数引用外部函数的变量的时候，外部函数在执行的时候产生闭包。闭包的作用：闭包的作用就是在函数以外的任何地方访问到函数内的变量对象，使用闭包的内部函数在内存中执行完毕之后，引用的变量会一直存在函数中，延长了变量的声明周期。缺点：javascript有一个垃圾回收机制，在桟堆里声明的变量当在内存中调用并且没有使用的话，在运行当中就会被当成垃圾回收，当一个嵌套函数引用外部函数的变量的时候，外部函数在执行的时候产生闭包，由于闭包的特性变量会一直存在函数中javascript的回收机制收回不了闭包的引用，会导内存的泄露和性能的损耗。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack学习——工作原理（上）]]></title>
    <url>%2F2019%2F04%2F24%2Fwebpack%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[对于webpack的认识，项目中用到vue的前端工程师对vue-cli脚手架应该都不陌生，不得不说脚手架既方便而且很好用，修改起来也很方便，有使用经验的都知道webpack里面各个配置项的功能，打包的时候只需要一句npm run build就可以完成打包工作了，可是webpack我们还不知道打包的过程中发生了什么，它是如何去运作的，打包的时候报错，也只是通过goole，baidu来帮忙解决问题，搜索出来后至于为什么要这样修改，什么原理，很少人会去纠结，不管，能解决就好的心态。所以，了解原理也是很有必要的，对于换工作的小伙伴面试的时候有好处。 概念每个开发工具都会有自己的运行原理，webpack首先得明白几个概念。 Enrty: 入口，webpack构建的起始点。 Module: 模块，webpack里面一切皆是模块，也是代表着文件，从Enrty配置的入口开始，递归找出依赖的模块。 Chunk: 代码块，找出递归依赖模块经转换后组合成代码块。 Loader: 模块转换器，也就是将模块的内容按照需求转换成新内容。 Plugin: 扩展插件，webpack构建过程中，会在特定的时机广播对应的时间，而插件可以监听这些事件的发生。 流程webpack构建流程，详细过程如下: 初始化: 从配置文件或者是shell（一个梳理梳理代码逻辑的模块），得到最终参数，实例化插件new Plugin() 开始编译: 通过初始化得到了最终参数，实例化一个Compiler对象，加载插件（依次调用插件中的apply方法），通过执行Compiler.run开始编译。 确定入口: 根据配置中Entry找到所有入口文件（一般情况下只设置一个） 编译模块: 从Entry出发，调用配置的loader，对模块进行转发，同时找出模块依赖的模块（下文有解释怎么找），一次递归，直到所有依赖模块找到完成本步骤处理。 完成模块编译: 现在已经完成了模块的编译，使用loader对所有模块进行了转换，得到了转换后的新内容以及依赖关系。 输出资源: 根据与模块之间的依赖关系，组装成一个个chunk代码块，并且生成文件输出列表。 输出成功: 根据配置中的输出路径和文件名，将文件写入文件系统，完成构建。 事件整个构建打包的过程会发生很多事件，来供Plugin监听，这些事件具体看可以分为三个阶段，分别是初始化阶段、编译阶段、输出阶段，具体介绍下表： 初始化阶段 事件 作用 初始化 从配置文件或者是shell（一个梳理梳理代码逻辑的模块），得到最终参数，实例化插件new Plugin() 实例化Compiler 通过初始化得到了最终参数，实例化一个Compiler对象，加载插件（依次调用插件中的apply方法），通过执行Compiler.run开始编译 加载插件 依次调用插件中的apply方法，同时也会将Compiler对象实例传入，就可以调用Webpack提供的API,compiler实例可以说是Webpack实例 environment 将node.js风格的文件系统应用到compiler对象，便可以直接通过compiler来对文件进行操作 entry-option 读取配置中的Entry，依次实例化出对应EntryPlugin，为后面该Entry的递归解析工作做准备 after-plugins 调完所有内置和配置的插件的apply方法 after-resolvers 根据配置初始化resolvers，resolvers负责在文件系统中寻找指定路径的文件 编译阶段输出化阶段总结]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJS中学习使用Vuex详解]]></title>
    <url>%2F2019%2F03%2F18%2FVueJS%E4%B8%AD%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8Vuex%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[小结一下vuex的作用和一点自己的理解 ##什么是vuex 在SPA单页面组件的开发中 Vue的vuex和React的Redux 都统称为同一状态管理，个人的理解是全局状态管理更合适；简单的理解就是你在state中定义了一个数据之后，你可以在所在项目中的任何一个组件里进行获取、进行修改，并且你的修改可以得到全局的响应变更。下面咱们一步一步地剖析下vuex的使用: 首先要安装、使用 vuex 首先在 vue 2.0+ 你的vue-cli项目中安装 vuex :1npm install vuex --save 然后 在src文件目录下新建一个名为store的文件夹，为方便引入并在store文件夹里新建一个index.js,里面的内容如下: 123456import Vue from &apos;vue&apos;;import Vuex from &apos;vuex&apos;;Vue.use(Vuex);const store = new Vuex.Store(); export default store; 接下来，在 main.js里面引入store，然后再全局注入一下，这样一来就可以在任何一个组件里面使用this.$store了：123456789import store from &apos;./store&apos;//引入store new Vue(&#123; el: &apos;#app&apos;, router, store,//使用store template: &apos;&lt;App/&gt;&apos;, components: &#123; App &#125;&#125;) 说了上面的前奏之后，接下来就是纳入正题了，就是开篇说的state的玩法。回到store文件的index.js里面，我们先声明一个state变量，并赋值一个空对象给它，里面随便定义两个初始属性值；然后再在实例化的Vuex.Store里面传入一个空对象，并把刚声明的变量state仍里面：12345678910111213import Vue from &apos;vue&apos;;import Vuex from &apos;vuex&apos;;Vue.use(Vuex); const state=&#123;//要设置的全局访问的state对象 showFooter: true, changableNum:0 //要设置的初始属性值 &#125;; const store = new Vuex.Store(&#123; state &#125;); export default store; 实际上做完上面的三个步骤后，你已经可以用this.$store.state.showFooter或this.$store.state.changebleNum在任何一个组件里面获取showfooter和changebleNum定义的值了，但这不是理想的获取方式；vuex官方API提供了一个getters，和vue计算属性computed一样，来实时监听state值的变化(最新状态)，并把它也仍进Vuex.Store里面，具体看下面代码:123456789101112131415161718192021import Vue from &apos;vue&apos;;import Vuex from &apos;vuex&apos;;Vue.use(Vuex); const state=&#123; //要设置的全局访问的state对象 showFooter: true, changableNum:0 //要设置的初始属性值 &#125;;const getters = &#123; //实时监听state值的变化(最新状态) isShow(state) &#123; //方法名随意,主要是来承载变化的showFooter的值 return state.showFooter &#125;, getChangedNum()&#123; //方法名随意,主要是用来承载变化的changableNum的值 return state.changebleNum &#125;&#125;;const store = new Vuex.Store(&#123; state, getters&#125;);export default store; 光有定义的state的初始值，不改变它不是我们想要的需求，接下来要说的就是mutations了，mutattions也是一个对象，这个对象里面可以放改变state的初始值的方法，具体的用法就是给里面的方法传入参数state或额外的参数,然后利用vue的双向数据驱动进行值的改变，同样的定义好之后也把这个mutations扔进Vuex.Store里面，如下：123456789101112131415161718192021222324252627282930313233import Vue from &apos;vue&apos;;import Vuex from &apos;vuex&apos;;Vue.use(Vuex); const state=&#123; //要设置的全局访问的state对象 showFooter: true, changableNum:0 //要设置的初始属性值 &#125;;const getters = &#123; //实时监听state值的变化(最新状态) isShow(state) &#123; //承载变化的showFooter的值 return state.showFooter &#125;, getChangedNum()&#123; //承载变化的changebleNum的值 return state.changableNum &#125;&#125;;const mutations = &#123; show(state) &#123; //自定义改变state初始值的方法，这里面的参数除了state之外还可以再传额外的参数(变量或对象); state.showFooter = true; &#125;, hide(state) &#123; //同上 state.showFooter = false; &#125;, newNum(state,sum)&#123; //同上，这里面的参数除了state之外还传了需要增加的值sum state.changableNum+=sum; &#125;&#125;; const store = new Vuex.Store(&#123; state, getters, mutations&#125;);export default store; 这时候你完全可以用 this.$store.commit(‘show’) 或 this.$store.commit(‘hide’) 以及 this.$store.commit(‘newNum’,6) 在别的组件里面进行改变showfooter和changebleNum的值了，但这不是理想的改变值的方式；因为在 Vuex 中，mutations里面的方法 都是同步事务，意思就是说：比如这里的一个this.$store.commit(‘newNum’,sum)方法,两个组件里用执行得到的值，每次都是一样的，这样肯定不是理想的需求 好在vuex官方API还提供了一个actions，这个actions也是个对象变量，最大的作用就是里面的Action方法 可以包含任意异步操作，这里面的方法是用来异步触发mutations里面的方法，actions里面自定义的函数接收一个context参数和要变化的形参，context与store实例具有相同的方法和属性，所以它可以执行context.commit(‘ ‘),然后也不要忘了把它也扔进Vuex.Store里面：123456789101112131415161718192021222324252627282930313233343536373839404142434445import Vue from &apos;vue&apos;;import Vuex from &apos;vuex&apos;;Vue.use(Vuex); const state=&#123; //要设置的全局访问的state对象 showFooter: true, changableNum:0 //要设置的初始属性值 &#125;;const getters = &#123; //实时监听state值的变化(最新状态) isShow(state) &#123; //承载变化的showFooter的值 return state.showFooter &#125;, getChangedNum()&#123; //承载变化的changebleNum的值 return state.changableNum &#125;&#125;;const mutations = &#123; show(state) &#123; //自定义改变state初始值的方法，这里面的参数除了state之外还可以再传额外的参数(变量或对象); state.showFooter = true; &#125;, hide(state) &#123; //同上 state.showFooter = false; &#125;, newNum(state,sum)&#123; //同上，这里面的参数除了state之外还传了需要增加的值sum state.changableNum+=sum; &#125;&#125;; const actions = &#123; hideFooter(context) &#123; //自定义触发mutations里函数的方法，context与store 实例具有相同方法和属性 context.commit(&apos;hide&apos;); &#125;, showFooter(context) &#123; //同上注释 context.commit(&apos;show&apos;); &#125;, getNewNum(context,num)&#123; //同上注释，num为要变化的形参 context.commit(&apos;newNum&apos;,num) &#125;&#125;; const store = new Vuex.Store(&#123; state, getters, mutations, actions&#125;);export default store; 而在外部组件里进行全局执行actions里面方法的时候，你只需要用执行 this.$store.dispatch(‘hideFooter’) 或this.$store.dispatch(‘showFooter’) 以及this.$store.dispatch(‘getNewNum’，6) //6要变化的实参 dispatch：含有异步操作，例如向后台提交数据，写法： this.$store.dispatch(‘action方法名’,值) commit：同步操作，写法：this.$store.commit(‘mutations方法名’,值) 这样就可以全局改变showfooter或changebleNum的值了，如下面的组件中,需求是跳转组件页面后，根据当前所在的路由页面进行隐藏或显示页面底部的tabs选项卡12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view/&gt; &lt;FooterBar v-if=&quot;isShow&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import FooterBar from &apos;@/components/common/FooterBar&apos;import config from &apos;./config/index&apos;export default &#123; name: &apos;App&apos;, components:&#123; FooterBar:FooterBar &#125;, data()&#123; return &#123; &#125; &#125;, computed:&#123; isShow()&#123; return this.$store.getters.isShow; &#125; &#125;, watch:&#123; $route(to,from)&#123; //跳转组件页面后，监听路由参数中对应的当前页面以及上一个页面 console.log(to) if(to.name==&apos;book&apos;||to.name==&apos;my&apos;)&#123; // to.name来获取当前所显示的页面，从而控制该显示或隐藏footerBar组件 this.$store.dispatch(&apos;showFooter&apos;) // 利用派发全局state.showFooter的值来控制 this.$store.dispatch(&apos;hideFooter&apos;) &#125; else &#123; this.$store.dispatch(&apos;hideFooter&apos;) &#125; &#125; &#125;&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>vueJs</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[greenSock]]></title>
    <url>%2F2019%2F03%2F04%2FgreenSock%2F</url>
    <content type="text"><![CDATA[个人git仓库有相关包下载，打开终端clone下来1指令：git clone https://github.com/wx170903/greensock.git 基本操作——TweenMax.to( ); 123Jquery选择器选择1以变量保存起来var $box = $(&apos;#box&apos;);TweenMax.to($box, 7, &#123; &apos;left&apos;: 300, backgroundColor: &quot;pink&quot; &#125;);上面的代码会在7秒之内把$box元素从CSS中定义的位置移动到距离body-300px的边缘并且换成pink颜色。 基本操作——TweenMax.from( ); 123var $box = $(&apos;#box&apos;);TweenMax.from($box, 2, &#123;x: &apos;-=500px&apos;,repeat:-1, autoAlpha: 1&#125;);在代码中autoAlpha: 0表示它会把元素初始化为opacity:0;visibility:hidden。当执行动画效果的时候它会把visibility的值设置为inherit以及opacity值设置为1。从而产生一个渐现的效果。 基本操作——TweenMax.set( ); 123456有时候，我们只是想设置元素的一些CSS属性并不需要动画效果，比如，重设元素的位置。这个时候就可以使用GreenSock提供的.set()方法。注：定义的变量就不写出来的。TweenLite.set($box, &#123;x: &apos;-=200px&apos;, scale: 0.3&#125;);TweenLite.set($box, &#123;x: &apos;+=100px&apos;, scale: 0.6, delay: 1&#125;);TweenLite.set($box, &#123;x: &apos;-50%&apos;, scale: 1, delay: 2&#125;);运行上面的代码，可以看到元素只是单纯的在改变属性并没有动画效果。 基本操作——TweenMax.fromTo( ); 12345这个方法结合了上面的，从头到尾定义动画的起始位置并且不重复。TweenLite.fromTo($box, 2, &#123;x: &apos;0&apos;&#125;, &#123;x: 150&#125;);把上面的代码放入到JS代码中，就可以看到运行的动画效果。盒子从-=200px的位置走到150px的位置，在括号里面可以添置变化属性（比如颜色，大小，不透明度等）；x:150会覆盖在CSS中定义的transform: translate(–50%, –50%)的样式，用新的transform: matrix(1, 0, 0, 1, 150, -50);样式来代替。 接下来，可以给元素加一些缓动曲线，使之更符合真实的物体运动效果。GreenSock也提供了各种的运动曲线，来使动画效果更加自然。]]></content>
      <categories>
        <category>js动画</category>
      </categories>
      <tags>
        <tag>JS动画库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp使用小结]]></title>
    <url>%2F2018%2F12%2F24%2Fgulp%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一般简单的项目不会用到webpack搭建项目，推荐一下用gulp开发一些做比较简单的项目。 glup安装12$ npm install --global gulp-cli$ npm install --save-dev gulp 安装各种插件123456789101112131415npm install --save gulp //本地使用npm install --save gulp-imagemin //压缩图片npm install --save gulp-minify-css //压缩cssnpm install --save gulp-ruby-sass //sassnpm install --save gulp-jshint //js代码检测npm install --save gulp-uglify //js压缩npm install --save gulp-concat //文件合并npm install --save gulp-rename //文件重命名npm install --save png-sprite //png合并npm install --save gulp-htmlmin //压缩htmlnpm install --save gulp-clean //清空文件夹npm install --save browser-sync //文件修改浏览器自动刷新npm install --save gulp-shell //执行shell命令npm install --save gulp-ssh //操作远程机器npm install --save run-sequence //task顺序执行 创建glupfile.js123456789101112131415161718192021222324252627282930(示例1)var gulp = require(&apos;gulp&apos;);var pug = require(&apos;gulp-pug&apos;);var less = require(&apos;gulp-less&apos;);var minifyCSS = require(&apos;gulp-csso&apos;);var concat = require(&apos;gulp-concat&apos;);var sourcemaps = require(&apos;gulp-sourcemaps&apos;);gulp.task(&apos;html&apos;, function()&#123; return gulp.src(&apos;client/templates/*.pug&apos;) .pipe(pug()) .pipe(gulp.dest(&apos;build/html&apos;))&#125;);gulp.task(&apos;css&apos;, function()&#123; return gulp.src(&apos;client/templates/*.less&apos;) .pipe(less()) .pipe(minifyCSS()) .pipe(gulp.dest(&apos;build/css&apos;))&#125;);gulp.task(&apos;js&apos;, function()&#123; return gulp.src(&apos;client/javascript/*.js&apos;) .pipe(sourcemaps.init()) .pipe(concat(&apos;app.min.js&apos;)) .pipe(sourcemaps.write()) .pipe(gulp.dest(&apos;build/js&apos;))&#125;);gulp.task(&apos;default&apos;, [ &apos;html&apos;, &apos;css&apos;, &apos;js&apos; ]); glup 语法 glup.src() 转化的文件 123456789101112131415gulp.src(globs[, options])globs : String or Arrayglup.src(&apos;client/template/*.jade&apos;) .pipe(jade()) .pipe(minify()) .pipe(glup.dest(&apos;build/minifiled_templates&apos;))// 示例client/ a.js bob.js bad.jsglup.src([&apos;client/*.js&apos;, &apos;!client/b*.js&apos;, &apos;client/bad.js&apos;]) // 要所有.js结尾的文件, 不要以b开头的 , 要bad.js glup.dest() 数据流变成文件 12345678gulp.dest(path[, options])path: String or Functiongulp.src(&apos;./client/templates/*.jade&apos;) .pipe(jade()) .pipe(gulp.dest(&apos;./build/templates&apos;)) // 路径 .pipe(minify()) .pipe(gulp.dest(&apos;./build/minified_templates&apos;)); // 放置路径 glup.task() 声明一个任务 1234567891011gulp.task(name [, deps, fn])name: String 不应该有空格deps: Arrayfn: Functiongulp.task(&apos;somename&apos;, function() &#123; // Do ...&#125;);gulp.task(&apos;mytask&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;], function() &#123; // Do stuff&#125;); glup.watch() 监控文件的变动 12345678gulp.watch(glob[, opts], tasks)glob: String or Arraytasks: Arrayvar watcher = gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]);watcher.on(&apos;change&apos;, function(event) &#123; console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);&#125;); glup使用案例 demo1目录结构如下。把demo1中的 index.html压缩，把src里面的less编译、合并、压缩、重命名、存储到dist。src里面的图片压缩、合并存储到dist。src里面的js做代码检查，压缩，合并，存储到dist。 123456789101112131415161718192021+ demo1 + dist + css - merge.min.css + js - merge.min.js + imgs - 1.png - 2.png - index.html + src + css - a.css - b.css + js - a.js - b.js + imgs - 1.png - 2.png - index.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(glupfile.js) var gulp = require(&apos;gulp&apos;); // 引入组件 var minifycss = require(&apos;gulp-minify-css&apos;), // CSS压缩 uglify = require(&apos;gulp-uglify&apos;), // js压缩 concat = require(&apos;gulp-concat&apos;), // 合并文件 rename = require(&apos;gulp-rename&apos;), // 重命名 clean = require(&apos;gulp-clean&apos;), //清空文件夹 minhtml = require(&apos;gulp-htmlmin&apos;), //html压缩 jshint = require(&apos;gulp-jshint&apos;), //js代码规范性检查 imagemin = require(&apos;gulp-imagemin&apos;); //图片压缩 gulp.task(&apos;html&apos;, function() &#123; return gulp.src(&apos;src/*.html&apos;) .pipe(minhtml(&#123;collapseWhitespace: true&#125;)) .pipe(gulp.dest(&apos;dist&apos;)); &#125;); gulp.task(&apos;css&apos;, function(argument) &#123; gulp.src(&apos;src/css/*.css&apos;) .pipe(concat(&apos;merge.css&apos;)) .pipe(rename(&#123; suffix: &apos;.min&apos; &#125;)) .pipe(minifycss()) .pipe(gulp.dest(&apos;dist/css/&apos;)); &#125;); gulp.task(&apos;js&apos;, function(argument) &#123; gulp.src(&apos;src/js/*.js&apos;) .pipe(jshint()) .pipe(jshint.reporter(&apos;default&apos;)) .pipe(concat(&apos;merge.js&apos;)) .pipe(rename(&#123; suffix: &apos;.min&apos; &#125;)) .pipe(uglify()) .pipe(gulp.dest(&apos;dist/js/&apos;)); &#125;); gulp.task(&apos;img&apos;, function(argument)&#123; gulp.src(&apos;src/imgs/*&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;dist/imgs&apos;)); &#125;); gulp.task(&apos;clear&apos;, function()&#123; gulp.src(&apos;dist/*&apos;,&#123;read: false&#125;) .pipe(clean()); &#125;); gulp.task(&apos;build&apos;, [&apos;html&apos;, &apos;css&apos;, &apos;js&apos;, &apos;img&apos;]);$ glup build]]></content>
      <categories>
        <category>js工具</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>自动化构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端虚拟键盘和滚动穿透小结]]></title>
    <url>%2F2018%2F07%2F31%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%99%9A%E6%8B%9F%E9%94%AE%E7%9B%98%E5%92%8C%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[记录一下最近遇到的两个小bug，也不算小bug，可能在不同的移动端浏览器表现不同吧。一个是虚拟键盘顶起，一个是滚动穿透问题。 虚拟键盘首先需要明确的一点是，虚拟键盘的顶起在IOS端和Android端有很大的不同变现。 监听移动端软键盘弹起和收起1. Android端 监听resize1234567891011var winHeight = $(window).height();$(window).resize(function () &#123; var thisHeight = $(this).height(); if( winHeight - thisHeight &gt; 140) &#123; // 键盘弹起，140px是一个预估值，可更改 &#125; else &#123; // 键盘收起 &#125;&#125;) 2. IOS端 监听input失焦blurios中的键盘或者第三方键盘并不会监听到window resize事件，所以不能用resize监听，所以需要通过输入框是否获取焦点来判断。 在Android中，有一些机型，键盘收起了，输入框仍处于焦点状态，并没有触发focusout事件。 因为focusin和focusout支持冒泡，对应focus和blur，所以根据需求，我们可以选择相应的事件。 1234567$(document).on('focusin', function () &#123; //软键盘弹出的事件处理&#125;);$(document).on('focusout', function () &#123; //软键盘收起的事件处理&#125;); input textarea contenteditable=&quot;true&quot; 置底问题这里也需要了解一下，IOS和Android关于fixed属性的支持是不一样的。 1. IOS端ios中，虚拟键盘顶起来之后，整个页面都会被键盘部分压缩。也就是说页面的高度会变小，并且所有的fixed都会变成absolute。 也就是说，之前在ios端fixed到底部的input框等可focus元素，会变成absolute定位，并且随着页面能够滑动。 2. Android端android端中，虚拟键盘顶起来之后，fixed属性不会失效，唤起的键盘是覆盖在页面上的，不会压缩页面。 项目中的bug及一些思考在最近的一个项目中，移动端页面布局，因为现在手机的高度不同，简单的背景图并不能放文字了，文字会拉伸，我需要设置一个footer放到底部，这里我最开始考虑的就是用fixed布局到最底部，结果当键盘顶起来的时候，文字也就跟着一起顶上去了，整个页面使用的是overflow: hidden。 这里就需要监听键盘顶起事件，并执行相应的给元素添加相关css的功能。 123456789var oHeight = $(document).height();// 监听键盘事件$(window).resize(function () &#123; if ($(document).height() &lt; oHeight) &#123; $('footer').addClass('hide'); &#125; else &#123; $('footer').removeClass('hide'); &#125;&#125;); 另外，关于底部的输入框顶起的问题，我看了一下手机版微博的解决方案，在Android端，虚拟键盘顶起，应该直接是fixed在底部，在IOS端则是整个添加了一个评论的浮层，总来来说也是一个不错的方案。 最后介绍一个神奇的东西Element.scrollIntoView()，这个东西能把底部的输入框提高到可视区域，不过经过测试，键盘顶起是需要时间的，我们需要确保，在键盘调起之后，确保元素调用scrollIntoView()。 下面是我写的一段代码:12345$('#el').on('focus', function () &#123; setTimeout(() =&gt; &#123; document.querySelector('#el').scrollIntoView(); &#125;, 300);&#125;); 滚动穿透在移动端中，滚动穿透问题很常见，处理起来也比较繁琐。下面我还是按照不同的方法进行分类： touchmove事件中调用preventDefault()这个方法适用于，弹出框内容无需滚动。如果弹出层内部有滚动事件，将会导致，弹出层的滚动事件也无法滚动。 添加相关的类给html上添加一个noscroll的类12345.noscroll,.noscroll body overflow: hidden.noscroll body poition: relative 缺点： html和body的滚动都禁止了，弹出层关闭后，会丢失原有的滚动位置，需要用JS来还原 有些页面的北京还有能滚的动的效果 fixed加上js恢复记录位置css1234body.mask-open &#123; position: fixed; width: 100%;&#125; 12345678910111213141516171819var scrollTop = 0;open.onclick = function() &#123; scrollTop = document.body.scrollTop || document.documentElement.scrollTop; document.body.classList.add('mask-open'); document.body.style.top = -scrollTop + 'px'; // 脱离文档流后回到当前位置 mask.style.display = 'block';&#125;close.onclick = function() &#123; mask.style.display = 'none'; document.body.classList.remove('mask-open'); document.body.scrollTop = document.documentElement.scrollTop = scrollTop // 滚动到相应位置，确保兼容性&#125; 参考 虚拟键盘 https://cloud.tencent.com/developer/article/1004930 http://www.cnblogs.com/wangyihong/p/7514304.html 滚动穿透 https://segmentfault.com/q/1010000002942948 https://github.com/pod4g/tool/wiki/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98]]></content>
      <categories>
        <category>移动端bug</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>bug</tag>
        <tag>兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[touch事件&&mouse事件&&PC端&&移动端总结]]></title>
    <url>%2F2018%2F07%2F12%2Ftouch%E4%BA%8B%E4%BB%B6-mouse%E4%BA%8B%E4%BB%B6-PC%E7%AB%AF-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近几天看的东西比较杂，抽空做下小总结。本来想研究下PC端的mousedown，mousemove，mouseup在移动端的浏览器的表现，如何用touch来替代，结果不知不觉，重新看了下JS高程的事件处理章节，关于各种浏览器的clinetX,pageX也看了不少，接下来就做下总结了。 touches对象的各种参数触摸事件 touchstart: 手指放在屏幕上的时候出发：即使已经有一个手指放在屏幕上也会触发。 touchmove：当手指在屏幕上连续地出发。期间调用preventDefault()会阻止默认滚动。 touchend：当手指从屏幕上移开时出发。 touchcancel：当系统停止跟踪触摸时出发。 这几个事件都会冒泡，也都能取消。 下面放一下移动端跟踪触摸的时候三个event事件属性。 touches：表示当前跟踪的触摸操作的Touch对象的数组。 targetTouches：特定于事件目标的Touch对象的数组。 changedTouches：表示自上次触摸以来发生改变的Touch对象的数组。 touches下面是touches属性介绍： 属性 属性含义 clientX, Y 触摸目标在视口中的x, y坐标，不包括任何滚动偏移 force 触摸手指挤压触摸平面的压力大小0.0-1.0之间 identifier 表示触摸的唯一ID pageX, Y 触摸目标在页面中的x, y坐标 radiusX, Y 能够包围用户和触摸平面的接触面的最小椭圆的水平轴(X轴),垂直轴(Y轴)半径 rotationAngle 上述椭圆的能精准覆盖用户与触摸平面的接触面的角度，取值0-90之间 screenX, Y 返回触点相对于屏幕左边沿的的X, y坐标. 不包含页面滚动的偏移量 target 触摸touchstart触摸在屏幕上返回的element mouse事件的各种参数DOM3级事件中有九个鼠标事件，顺便放一下事件速查表. 事件名 触发条件 click 用户点击主鼠标按钮或者按下回车键触发 dbclick 用户双击主鼠标按钮触发 mousemove 鼠标指针在元素内部移动时重复触发 mouseup 用户释放鼠标shi mousedown 用户按下任意鼠标按钮触发，不能通过键盘触发这个事件 mouseenter 指针移到有事件监听的元素内（不冒泡） mouseleave 指针移出元素范围外（不冒泡） mouseover 指针移到有事件监听的元素或者它的子元素内 mouseout 指针移出元素，或者移到它的子元素上 这里了解一下click的顺序，mousedown -&gt; mouseup -&gt; click。这里click是依赖先行事件mousedown，mouseup运行的。也就是说，假如我们的拖动的div上绑定有一个click事件，拖动的过程中，就会在mouseup后面触发click事件。所以我们可以将click事件绑定到mouseup上面，判断是否有mousemove来考虑触发click上绑定的事件的时机。 事件处理，事件监听，事件委托DOM事件流规定中，事件流包含三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。在DOM事件流中，实际的元素在捕获阶段不会接收到事件。这意味着事件处理会被当做冒泡阶段的一部分。 事件处理的几种常见方法1. HTML事件处理程序直接在html上绑定一个事件，事件处理程序一般以&#39;on&#39;开头。123456789&lt;!-- 绑定执行语句 --&gt;&lt;input type="button" value="click me" onclick="alert('clicked')"/&gt;&lt;!-- 绑定函数 --&gt;&lt;input type="button" value="click me" onclick="showMessage()" /&gt;&lt;script&gt; function showMessage() &#123; alert('clickclickclicked!') &#125;&lt;/script&gt; 上述事件处理程序会创建一个封装着元素属性值的函数。这个函数中有一个局部变量event，也就是事件对象。 通过event变量，可以直接访问到事件对象，你不用从函数的参数列表读取。在函数内部，this等于事件的目标元素。那么这里需要注意了，事件处理函数中的this指向的问题。所以在需要添加到this的函数中，我们有时会用词法作用域context来保存需要调用的上下文。像上一篇文章中函数节流，就用到了相关保存运行时this的方法。 2. DOM 0级事件处理使用传统的JavaScript指定事件处理方式，先获取到相关的需要操作对象的引用。 每个元素都有自己的事件处理程序属性，这些属性通常全部小写。 12345678var btn = document.getElementById('myBtn');btn.onclick = function() &#123; alert('this.id'); // 'myBtn'&#125;// 清空事件绑定btn.onclick = null; 这种形式添加的事件处理程序会在事件流的冒泡阶段被处理。 3. DOM 2级事件处理程序所有的DOM节点都包含两个方法，addEventListener()和removeEventListener()，并接受三个参数：事件名，作为事件处理程序的函数和一个布尔值。 123456789101112131415161718var btn = document.getElementById('myBtn');btn.addEventListener('click', function() &#123; console.log('hello hdd');&#125;, false);btn.removeEventListener('click', function() &#123; // 没有用 console.log('hello hdd');&#125;, false); // 上述代码无法删除相关的事件处理函数，因为两个匿名函数不是同一个函数了。var btn = document.getElementById('myBtn');var handler = function() &#123; console.log('hello hdd');&#125;;btn.addEventListener('click', handler, false);btn.removeEventListener('click', handler, false); 事件对象event对象包含与创建它的特定事件有关的属性和方法。触发的事件类型不一样，可用的属性和方法也不一样。不过所有事件都会有下表列出的成员。下表的属性都是只读的。 属性/方法 类型 说明 bubbles Boolean 表明事件是否冒泡 cancelable Boolean 表明是否可以取消事件的默认行为 currentTarget Element 其事件处理程序当前正在处理的那个元素 defaultPrevented Boolean 是否调用preventDefault() detail Integer 与事件相关的细节信息 eventPhase Interger 调用事件处理程序的阶段：1.捕获阶段2.处于目标3.冒泡阶段 preventDefault() Function 取消事件的默认行为。如果cancelable是true，则可以使用这个方法 stopImmediatePropagation() Function 取消事件的进一步捕获或冒泡，同时阻止任何使劲按处理程序被调用 stopPropagation Function 取消使劲按的进一步捕获或冒泡。如果bubbles为true，则可以使用这个方法 target Element 事件的目标 trusted Boolean true表示浏览器生成的，false表示开发者通过JavaScript创建的 type String 被触发的事件类型 view AbstractView 与事件关联的抽象试图。等同于发生对象的window对象 在事件处理程序的内部，this始终等于currentTarget的值，而target则只包含事件的实际目标。下面点击子元素： 子元素绑定事件处理程序，父元素绑定事件处理函数。currentTarget等于父元素，target等于子元素 子元素不绑定事件处理程序，父元素绑定事件处理函数。currentTarget等于父元素，target等于子元素 子元素绑定事件处理程序，父元素不绑定事件处理函数。currentTarget等于子元素，target等于子元素 下面看几种常见的事件处理的冒泡次序： 12345678910111213var btn = document.getElementById('myBtn');btn.onclick = function(event) &#123; alert(event.eventPhase); // 2&#125;;document.body.addEventListener('click', function(event) &#123; alert(event.eventPhase); // 1&#125;, true);document.body.onclick = function(event) &#123; alert(event.eventPhase); // 3&#125;; 最后，事件处理程序执行期间，event对象一直存在，一旦事件处理程序执行完成，event对象就会销毁。 事件委托想页面添加大量的事件处理程序会占用大量的内存，内存中的对象越多，性能也就越差。而且，必须事先指定所有事件处理程序而导致的DOM访问次数会延迟整个页面的交互就绪时间。 要理解事件委托，事件冒泡和捕获必须梳理一下。 当一个事件发生在具有父元素的元素导航，现代浏览器运行两个不同的阶段-捕获阶段和冒泡阶段。 在现代浏览器中，默认情况下，多有时间处理程序都在冒泡阶段注册，因此当我们点击子元素的时候。会沿着这个事件冒泡线路： 发现了子元素的事件处理程序，并运行了它。 往外冒泡发现父元素的事件处理程序，并运行它。 避免这个问题的方法就是使用stopPropagation()修复问题。 利用了事件冒泡会发现父元素的事件处理程序。我们就可以利用事件委托。 如果我们有大量子元素，想要点击任何一个都可以运行一段代码，可以将事件监听器设置在父节点元素，而且对于新添加的元素，事件委托很好的能为动态添加的元素动态的绑定事件处理函数。下面是例子 12345&lt;ul id="lists"&gt; &lt;li id="list1"&gt;列表第一项&lt;/li&gt; &lt;li id="list2"&gt;列表第二项&lt;/li&gt; &lt;li id="list3"&gt;列表第三项&lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617var list = document.getElementById('lists');document.addEventListener('click',function(event) &#123; // 也可以绑定lists元素 var target = event.target; switch(target.id) &#123; case 'list1': console.log(target.innerHTML); break; case 'list2': console.log('我是第二项'); break; case 'list3': alert('hello world'); break; &#125;&#125;) 浏览器中事件相关的常见几种位置坐标clientX/Y获取到的是触发点相对浏览器可视区域左上角距离，不随页面滚动而改变。 pageX/YpageX/Y获取到的是触发点相对文档区域左上角距离，会随着页面滚动而改变。 offsetX/YoffsetX/Y获取到是触发点相对被触发dom的左上角距离，不过左上角基准点在不同浏览器中有区别，其中在IE中以内容区左上角为基准点不包括边框，如果触发点在边框上会返回负值，而chrome中以边框左上角为基准点。 layerX/YlayerX/Y获取到的是触发点相对被触发dom左上角的距离，数值与offsetX/Y相同，这个变量就是firefox用来替代offsetX/Y的，基准点为边框左上角，但是有个条件就是，被触发的dom需要设置为position:relative或者position:absolute，否则会返回相对html文档区域左上角的距离。 screenX/YscreenX/Y获取到的是触发点相对显示器屏幕左上角的距离，不随页面滚动而改变。 一个图解释： 简单的移动端/PC端拖动代码 上面的代码中，我将事件的type做了一下判断，进而绑定相关的。 关于拖拽事件的常见bug及处理方式介绍下常见的，拖拽小问题。 1. 鼠标移动过快，离开拖拽物体由于拖拽的div太小了，拖拽物体不在随着鼠标移动，前面介绍事件的时候也提到了，鼠标移动元素，mousemove事件不再触发，这时我们可以将拖拽物体上的mousemve事件放到document上面，同时将mouseup也改为document上面的事件 2. 会出现将div脱出浏览器窗口限制div的拖动距离 还有一些常见bug，一般阻止默认事件都可以解决。 部分参考 http://www.cnblogs.com/moqiutao/p/5050225.html http://www.cnblogs.com/yufann/p/JS-Summary9.html]]></content>
      <categories>
        <category>JS工具</category>
      </categories>
      <tags>
        <tag>JS基础事件</tag>
        <tag>触摸</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的JS-this和原型对象]]></title>
    <url>%2F2018%2F05%2F14%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS-this%E5%92%8C%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[这里我总结了下，《你不知道的javaScript上卷》第二部分的内容，总结的可能比较简短，相关的知识点，与设计模式中间有重合，设计模式中的相关设计模式，后期也会补上。 关于this为什么要用this呢？如果没有this，我们需要调用变量名，才能在函数或者方法中调用相关它自己，如果有了this，我们就能用一种更优雅的方式“传递”一个对象的引用。因此可以将API设计的更加简洁并且易于复用。 随着你使用的模式越来越复杂，显示传递上下文对象会使代码变得越来越混乱，使用this则不会这样。 误解关于两种常见的对于this的解释，但是他们都是错误的。 指向自身很多人很容易吧this联想到它的英文意思，指向函数本身，但是this的绑定是动态的！ 看一个例子吧 12345678910111213141516171819function foo(num) &#123; console.log( "foo: " + num ); // 记录 foo 被调用的次数 this.count++;&#125;foo.count = 0;var i;for (i=0; i&lt;10; i++) &#123; if (i &gt; 5) &#123; foo( i ); &#125;&#125;// foo: 6// foo: 7// foo: 8// foo: 9// foo 被调用了多少次？console.log( foo.count ); // 0 -- WTF? 上面的this绑定到哪里了呢？答案是全局。 它的作用域第二种常见的误解是，this指向函数的作用域。 再看一个例子。 12345678910function foo() &#123; var a = 2; this.bar();&#125;function bar() &#123; console.log( this.a );&#125;foo(); // ReferenceError: a is not defined 这里我们既想用词法作用域，又想调用this来引入我们想用的函数体的变量。 这里稍微解析一下， this.bar() 引用的是外部的全局的 bar() 函数，这样里面的语句， console.log(this.a) 查找的也是全局的 a 变量。我们知道函数定义的 a 变量是影响不了全局的 a 变量的。所以这里我们会抛出一个引用错误。 this到底是什么排除了错误的理解后，我们看看this到底是什么样的机制。 之前我们说过this是在运行时进行绑定的，并不是在编写时绑定，他的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置灭有任何关系，只取决于函数的调用方式。 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等消息。this就是记录的其中一个属性，会在函数执行的过程中用到。 下一章我们会学习如何寻找函数的滴啊用位置，从而判断函数在执行的过程中会如何绑定this。 this全面解析调用位置就像前面说的，调用位置就是函数在代码中被调用的位置（而不是声明的位置）。只有仔细分析调用位置才能回答这个问题：这个this到底引用的是什么？ 通常来说，寻找滴啊用位置就是寻找“函数被调用的位置”，但是做起来没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。 最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中。 12345678910111213141516171819function baz() &#123; // 当前调用栈是：baz // 因此，当前调用位置是全局作用域 console.log( "baz" ); bar(); // &lt;-- bar 的调用位置&#125;function bar() &#123; // 当前调用栈是 baz -&gt; bar // 因此，当前调用位置在 baz 中 console.log( "bar" ); foo(); // &lt;-- foo 的调用位置&#125;function foo() &#123; // 当前调用栈是 baz -&gt; bar -&gt; foo // 因此，当前调用位置在 bar 中 // 这里放一个断点可以查看当前调用栈，倒数第二个就是真正的调用位置。 console.log( "foo" );&#125;baz(); // &lt;-- baz 的调用位置 绑定规则这里也简要的解释四种规则： 1. 默认绑定最常用的函数调用类型：独立函数调用。可以把这条规则看做是无法应用其他规则时的默认规则。 123456function foo() &#123; console.log( this.a );&#125;var a = 2;foo(); // 2 怎么知道应用了默认绑定呢？可以通过调用位置来看看 foo() 是如何调用的。在代码中，foo()是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。如果使用严格模式，将默认无法使用默认绑定的，因为this会绑定为undefined。 2. 隐式绑定另一种需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。 常见的对象的方法，就是隐式绑定。对象属性引用链只有最顶层或者说最后一层会影响调用位置。 12345678910111213function foo() &#123; console.log( this.a );&#125;var obj2 = &#123; a: 42, foo: foo&#125;;var obj1 = &#123; a: 2, obj2: obj2&#125;;obj1.obj2.foo(); // 42 隐式丢失因为this的绑定会根据runtime，所以，思考下面的代码： 1234567891011121314function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo;var a = "全局对象a";bar(); // 全局对象a 还有一种是常见的回调函数中的this隐式丢失，看下面代码：123456789101112131415161718function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = "oops, global"; // a 是全局对象的属性setTimeout( obj.foo, 100 ); // "oops, global"// JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似：function setTimeout(fn,delay) &#123; // 等待 delay 毫秒 fn(); // &lt;-- 调用位置！&#125; 接下来，我们会介绍相关的通过固定this来fix,this所指向的对象或者说上下文context。 3. 显示绑定分析隐式绑定时，我们必须在一个对象的内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把this间接（隐式）绑定到这个对象上。 我们可以通过call(..)和apply(..)方法，来在某个函数中强制指定到this的上下文。 12345678function foo() &#123; console.log( this.a );&#125;var obj = &#123; a:2&#125;;foo.call( obj ); // 2 可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题。 1. 硬绑定思考下面代码：1234567891011function foo() &#123; console.log(this.a);&#125;var obj = function() &#123; foo.call(obj);&#125;;var bar = function() &#123; foo.call(obj);&#125;; 这里，我们在 bar 内部实现了一个 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj 。无论之后如何调用函数 bar ，它总会在 obj 上调用 foo 。这种绑定是一种显式的强制绑定，因此我们称之为 硬绑定。 ES5中提供了内置的方法，Function.prototype.bind 2. API调用的“上下文”第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调函数使用指定的 this。 举个栗子：12345678910function foo(el) &#123; console.log( el, this.id );&#125;var obj = &#123; id: "awesome"&#125;;// 调用 foo(..) 时把 this 绑定到 obj[1, 2, 3].forEach( foo, obj );// 1 awesome 2 awesome 3 awesome 这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样你可以少些一些代码。 4. new绑定在JavaScript中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数。 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建（或者说构造）一个全新的对象。 这个新对象会被执行[[原型]]连接。 这个新对象会绑定到函数调用的 this 。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 优先级 函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象。 函数是否通过call、apply（显示绑定）或者硬绑定调用？如果是的话，this绑定的是制定的对象。 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。 绑定例外在某些场景下 this 的绑定行为会出乎意料，你认为应当应用其他绑定规则时，实际上应用的可能是默认绑定规则。 1. 被忽略的this如果你把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用的时候会被忽略，实际应用的是默认绑定规则。 如果函数并不关心this的话，你仍然需要传入一个占位符，常见的就是用null，可是这里用null来忽略this绑定可能会产生一些副作用。如果这个函数中确实使用了this，那默认绑定规则会把this绑定到全局对象，在浏览器这个对象是window，这将产生不可预计的后果。 更安全的this 一种“更安全”的做法是，闯入一个特殊的对象，常见方法，Object.create(null)。如果引入的是这个空对象，这样就比较安全了，这样很明确的表示this是空，即使函数中调用了this，也不会更改全局对象。 12345678910111213function foo() &#123; this.a = 200 console.log(this.a);&#125;var a = 2;var ø = Object.create(null)foo.call(ø)console.log(a)// 200 2 2. 间接引用另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。 常见的就是赋值的时候发生。 注意：对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则this 会被绑定到全局对象。 3. 软绑定123456789101112131415161718if (!Function.prototype.softBind) &#123; Function.prototype.softBind = function(obj) &#123; var fn = this; // 捕获所有 curried 参数 var curried = [].slice.call( arguments, 1 ); var bound = function() &#123; return fn.apply( (!this || this === (window || global)) ? obj : this curried.concat.apply( curried, arguments ) ); &#125;; bound.prototype = Object.create( fn.prototype ); return bound; &#125;;&#125; softBind(..)的其他原理和ES5内置的bind(..)类似。它会对制定函数进行封装，首先会检查调用时的this，如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this，否则不会修改this。1234567891011121314151617181920function foo() &#123; console.log("name: " + this.name);&#125;var obj = &#123; name: "obj" &#125;, obj2 = &#123; name: "obj2" &#125;, obj3 = &#123; name: "obj3" &#125;;var fooOBJ = foo.softBind( obj );fooOBJ(); // name: objobj2.foo = foo.softBind(obj);obj2.foo(); // name: obj2 &lt;---- 看！！！fooOBJ.call( obj3 ); // name: obj3 &lt;---- 看！setTimeout( obj2.foo, 10 );// name: obj &lt;---- 应用了软绑定 this词法这里介绍一下箭头函数: () =&gt; {}12345678910111213141516function foo() &#123; return (a) =&gt; &#123; console.log(this.a); &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3&#125;;var bar = foo.call(obj1);bar.call(obj2); foo() 内部创建的箭头函数会捕获调用时foo()的this。由于 foo() 的this绑定到obj1，bar（引用箭头函数）的this也会绑定到obj1，箭头函数的绑定无法被修改。（new也不行！） 对象两种形式的定义：声明（文字）形式和构造形式。 类型了解一下，简单基本类型：string、number、boolean、null和undefined。null有时会被当做一种对象类型，但是这其实只是语言本身的一个bug。 JS中有很多复杂基本类型。这些是一些特殊的对象子类型。函数就是对象的一个子类型（从技术角度来说就是“可调用的对象”） Javascript中的函数是“一等公民”，因为它们本质上和普通的对象一样（只是可以调用），所以可以像操作其他对象一样操作函数（比如当做另一个函数的参数）。 内置对象内置对象有：String、Number、Boolean、Object、Function、Array、Date、RegExp和Error。 关于字面量的基本类型调用 Object.prototype.toString() 都会转化成对应的包装类型。 内容内容听名字似乎存储在对象内部，其实在语言中，这些值的储存方式是多种多样的，一般不会存在对象容器的内部。存储在对象容器的内部的是这些属性的名称，它们就像指针（从技术角度来说就是引用）一样，指向这些值真正的存储位置。 .a通常指的是属性访问，[“a”] 语法通常被称为“键访问”。在 [&quot;..&quot;] 语法使用字符串来访问属性，所以可以在程序中构造这个字符串。 可计算属性名12345678var prefix = "foo";var myObject = &#123; [prefix + "bar"]: "hello", [prefix + "baz"]: "world"&#125;;myObject["foobar"]; // hellomyObject["foobaz"]; // world 属性与方法如果访问的对象是一个函数，在JS中，我们喜欢称之为 “方法”，实际上呢，这个所谓的“方法”也仅仅是对方法的引用。 数组数组支持[]访问形式，不过数组期待的是数字下标。所以你添加的属性值并不会使数组的length变长。你完全可以把数组当做一个普通的键/值对来使用。 而且要注意了：如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成一个数值下标（因此会修改数组的内容而不是添加一个属性） 1234567var myArray = [ "foo", 42, "bar" ];myArray["3"] = "baz";myArray.length; // 4myArray[3]; // "baz" 复制对象复制不可避免需要讨论到的就是深拷贝和浅拷贝。 对于JSON安全的对象，这有一种方法可以用：var newObj = JSON.parse( JSON.stringify( someObj ) ); ES6中定义的 Object.assign(..) 可以用在浅拷贝上，Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或者多个源对象。它会遍历一个或多个源对象的多有自由键并把它们复制（使用 = 操作符赋值）到目标对象，最后返回目标对象。 属性描述符在ES5之前，JavaScript语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否是只读。 1234567891011var myObject = &#123;a:2&#125;;Object.getOwnPropertyDescriptor( myObject, "a" );// &#123;// value: 2,// writable: true,// enumerable: true,// configurable: true// &#125; Object.getOwnPropertyDescriptor(..)和Object.defineProperty(..)了解一下。 常见配置： Writable 是否可以修改属性的值 Configurable 只要属性是可配置的，就可以使用 defineProperty(..) 方法来修改属性描述符。关于Configurable配置为false，writable可以由true变为false，并且不能再变回来啦！操作不可逆哈。 Enumerable 最后一个属性描述符（还有两个，我们会在介绍 getter 和 setter 时提到）是 enumerable。 放一下总结好了，这本书就总结到这里了： 小结JavaScript 中的对象有字面形式（比如 var a = { .. }）和构造形式（比如 var a = newArray(..)）。字面形式更常用，不过有时候构造形式可以提供更多选项。 许多人都以为“JavaScript 中万物都是对象”，这是错误的。对象是 6 个（或者是 7 个，取决于你的观点）基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。 对象就是键 / 值对的集合。可以通过 .propName 或者 [“propName”] 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [[Get]] 操作（在设置属性值时是 [[Put]]），[[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话还会查找 [[Prototype]]链（参见第 5 章）。 属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象（及其属性）的不可变性级别。 属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。 你可以使用 ES6 的 for..of 语法来遍历数据结构（数组、对象，等等）中的值，for..of会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>你不知道的JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的JS总结-作用域和闭包(二)]]></title>
    <url>%2F2018%2F02%2F05%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E6%80%BB%E7%BB%93-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[关于你不知道的JS总结-作用域和闭包的第二部分。 第 4 章 提升先有鸡还是先有蛋关于JS的代码执行顺序，直觉上是由上到下一行一行执行的。实际上并不完全正确，考虑下下面的代码123a = 2;var a;console.log( a ); 你认为console.log( a );声明会输出什么呢？很多人会认为是undefined，其实真实的输出结果是2。而12console.log( a );var a = 2; 这段代码输出结果又是ReferenceError异常。 按照第一章的编译器顺序，正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。 所以看到的var a = 2;其实是var a; 和 a = 2;两个声明。代码的编译过程是如下：12345678var a;a = 2;console.log(a);// 加上顺序，流程如下：var a;console.log(a);a = 2; 从上面的例子可以看出，是现有声明，再有赋值。这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了最上面。这个过程就叫作提升。 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。 关于函数的声明首先看一段代码：12345foo();function foo() &#123; console.log( a ); // undefined var a = 2;&#125; foo 函数的声明（这个例子还包括实际函数的隐含值）被提升了，因此第一行中的调用可以正常执行。 正确的执行顺序：123456function foo() &#123; var a; console.log( a ); // undefined a = 2;&#125;foo(); 函数声明会被提升，但是函数表达式却不会被提升。 下面看一段函数表达式的代码片段：1234567891011121314foo(); // TypeErrorbar(); // ReferenceErrorvar foo = function bar() &#123;// ...&#125;;// 经过提升var foo;foo(); // TypeErrorbar(); // ReferenceErrorfoo = function() &#123; var bar = ...self... // ...&#125; 函数优先函数声明和变量声明都会被提升，那么哪一个的优先权大呢？答案就在标题。看这一段代码：12345678foo(); // 1var foo;function foo() &#123; console.log( 1 );&#125;foo = function() &#123; console.log( 2 );&#125;; 这个代码片段会被引擎理解为如下形式：1234567function foo() &#123; console.log( 1 );&#125;foo(); // 1foo = function() &#123; console.log( 2 );&#125;; 尽管 var foo 出现在function foo()...，但它是一个重复的声明，会被忽略掉。因为函数声明会被提升到普通变量之前。 而且，后面的函数声明会覆盖前面的声明。12345678910foo(); // 3function foo() &#123; console.log( 1 );&#125;var foo = function() &#123; console.log( 2 );&#125;;function foo() &#123; console.log( 3 );&#125; 一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程 不会像下面的代码暗示的那样可以被条件判断所控制：12345678foo(); // "b"var a = true;if (a) &#123; function foo() &#123; console.log("a"); &#125;&#125;else &#123; function foo() &#123; console.log("b"); &#125;&#125; 总结我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。 这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。 声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。 要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引起很多危险的问题！ 第 5 章 作用域闭包启示闭包无处不在，你所需要的只是理解它 实质问题闭包的定义： 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 下面这段代码的定义：12345678function foo() &#123; var a = 2; function bar() &#123; console.log( a ); // 2 &#125; bar();&#125;foo(); 上面的代码中，基于词法作用域，函数bar()可以访问外部作用域中的变量a（利用RHS引用调用）。这里的词法作用域的利用，是闭包的一部分，也是最重要的一部分。 从纯学术的角度说，函数 bar() 具有一个涵盖 foo() 作用域的闭包（事实上，涵盖了它能访问的所有作用域，比如全局作用域））。也可以认为 bar() 被封闭在了 foo() 的作用域中。为什么呢？原因简单明了，因为 bar() 嵌套在 foo() 内部。123456789function foo() &#123; var a = 2; function bar() &#123; console.log( a ); &#125; return bar;&#125;var baz = foo();baz(); // 2 —— 朋友，这就是闭包的效果。 函数bar()的词法作用域能够访问foo()的内部作用域。然后我们将bar()函数本身当做一个值类型进行传递。上面这个例子中，我们就是将bar所应用的函数对象本身当做返回值。 在foo()执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz()，实际上只是通过不同的标识符引用调用了内部的函数bar()。 bar()显然可以被正常执行，但是在这个例子中，它在自己定义的词法作用域以外的地方执行。 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。 而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。 拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。 bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。 因此，在几微秒之后变量 baz 被实际调用（调用内部函数 bar），不出意料它可以访问定义时的词法作用域，因此它也可以如预期般访问变量 a。 这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。 当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。 1234567891011function foo() &#123; var a = 2; function baz() &#123; console.log( a ); // 2 &#125; bar( baz );&#125;function bar(fn) &#123; fn(); // 妈妈快看呀，这就是闭包！&#125; 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。 现在我懂了来看这段代码。123456function wait(message) &#123; setTimeout( function timer() &#123; console.log( message ); &#125;, 1000 );&#125;wait( "Hello, closure!" ); 将一个内部函数（名为 timer）传递给 setTimeout(..)。timer 具有涵盖 wait(..) 作用域的闭包，因此还保有对变量 message 的引用。 wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失，timer 函数依然保有 wait(..)作用域的闭包。 深入到引擎的内部原理中，内置的工具函数 setTimeout(..) 持有对一个参数的引用，这个参数也许叫作 fn 或者 func，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的 timer 函数，而词法作用域在这个过程中保持完整。 这就是闭包。 本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！ IIFE模式，因为函数（示例代码中的 IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行。这是是创建了一个闭包但是并不能调用。 循环和闭包要说明闭包，for循环是最常见的例子12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125; 我们预期的效果是:分别输出数字 1~5，每秒一次，每次一个。 得到的结果是，每秒一次的频率输出五次 6。 首先我们看一下6是怎么来的。这个例子中的终止条件是i&lt;=5。所以首次成立时的i的值是6，因此，输出显示的是循环结束时 i 的最终值。 仔细想一下，这好像又是显而易见的，延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0)，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。 缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。 我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。 首先试下IIFE12345678910111213141516for (var i=1; i&lt;=5; i++) &#123; (function() &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 ); &#125;)();&#125; // 这样的写法不行，为什么呢？因为每个IIFE中i的值并没有定义，也就是说这个作用于是空的// 改进for (var i=1; i&lt;=5; i++) &#123; (function(j) &#123; setTimeout( function timer() &#123; console.log( j ); &#125;, j*1000 ); &#125;)( i );&#125; 重返块作用域 我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。第 3 章介绍了 let 声明，可以用来劫持块作用域，并且在这个块作用域中声明一个变量。 本质上这是将一个块转换成一个可以被关闭的作用域。因此，下面这些看起来很酷的代码就可以正常运行了：123456789101112for (var i=1; i&lt;=5; i++) &#123; let j = i; // 是的，闭包的块作用域！ setTimeout( function timer() &#123; console.log( j ); &#125;, j*1000 );&#125;// for 循环头部的 let 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。for (let i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125; 模块还有其他的代码模式利用闭包的强大威力，但从表面上看，它们似乎与回调无关。下面一起来研究其中最强大的一个：模块。 模块模式需要具备两个必要条件。 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 小结闭包就好像从 JavaScript 中分离出来的一个充满神秘色彩的未开化世界，只有最勇敢的人才能够到达那里。但实际上它只是一个标准，显然就是关于如何在函数作为值按需传递的词法环境中书写代码的。 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。 如果没能认出闭包，也不了解它的工作原理，在使用它的过程中就很容易犯错，比如在循环中。但同时闭包也是一个非常强大的工具，可以用多种形式来实现模块等模式。 模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。 现在我们会发现代码中到处都有闭包存在，并且我们能够识别闭包然后用它来做一些有用的事！ 附录 A 动态作用域JS中作用域就是词法作用域，（事实上大部分语言都是基于词法作用域的）。 而JS中，this的机制，类似于动态作用域。 词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段（假设你没有使用eval() 或 with）。而动态作用域，是一个运行时被被动确定状态的形式。 例子:123456789function foo() &#123; console.log( a ); // 2&#125;function bar() &#123; var a = 3; foo();&#125;var a = 2;bar(); 词法作用域让 foo() 中的 a 通过 RHS 引用到了全局作用域中的 a，因此会输出 2。 而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。 因此，如果 JavaScript 具有动态作用域，理论上，上面代码中的 foo() 在执行时将会输出 3。 为什么会这样？因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。 附录 B 块作用域的替代方案第 3 章深入研究了块作用域。至少从 ES3 发布以来，JavaScript 中就有了块作用域，而with 和 catch 分句就是块作用域的两个小例子。 但随着 ES6 中引入了 let，我们的代码终于有了创建完整、不受约束的块作用域的能力。块作用域在功能上和代码风格上都拥有很多激动人心的新特性。 但如果我们想在 ES6 之前的环境中使用块作用域呢？ 12345&#123; let a = 2; console.log( a ); // 2&#125;console.log( a ); // ReferenceError 这段代码在 ES6 环境中可以正常工作。但是在 ES6 之前的环境中如何才能实现这个效果？答案是使用 catch。1234try&#123;throw 2;&#125;catch(a)&#123; console.log( a ); // 2&#125;console.log( a ); // ReferenceError 了解原理剩下就交给ES6转换器吧。 附录 C this 词法ES6 中有一个主题用非常重要的方式将 this同词法作用域联系起来了，我们会简单地讨论一下。 ES6 添加了一个特殊的语法形式用于函数声明，叫作箭头函数。1234var foo = a =&gt; &#123; console.log( a );&#125;;foo( 2 ); // 2 这里称作“胖箭头”的写法通常被当作单调乏味且冗长（挖苦）的 function 关键字的简写。 看这段代码：123456789var obj = &#123; id: "awesome", cool: function coolFn() &#123; console.log( this.id ); &#125;&#125;;var id = "not awesome"obj.cool(); // 酷setTimeout( obj.cool, 100 ); // 不酷 问题在于 cool() 函数丢失了同 this 之间的绑定。解决这个问题有好几种办法，但最长用的就是 var self = this;。 12345678910111213var obj = &#123; count: 0, cool: function coolFn() &#123; var self = this; if (self.count &lt; 1) &#123; setTimeout( function timer()&#123; self.count++; console.log( "awesome?" ); &#125;, 100 ); &#125; &#125;&#125;;obj.cool(); // 酷吧？ var self = this 这种解决方案圆满解决了理解和正确使用 this 绑定的问题，并且没有把问题过于复杂化，它使用的是我们非常熟悉的工具：词法作用域。 ES6 中的箭头函数引入了一个叫作 this 词法的行为：123456789101112var obj = &#123; count: 0, cool: function coolFn() &#123; if (this.count &lt; 1) &#123; setTimeout( () =&gt; &#123; // 箭头函数是什么鬼东西？ this.count++; console.log( "awesome?" ); &#125;, 100 ); &#125; &#125;&#125;;obj.cool(); // 很酷吧 ? 简单来说，箭头函数在涉及 this 绑定时的行为和普通函数的行为完全不一致。它放弃了所有普通 this 绑定的规则，取而代之的是用当前的词法作用域覆盖了 this 本来的值。 因此，这个代码片段中的箭头函数并非是以某种不可预测的方式同所属的 this 进行了解绑定，而只是“继承”了 cool() 函数的 this 绑定（因此调用它并不会出错）。 箭头函数将程序员们经常犯的一个错误给标准化了，也就是混淆了 this 绑定规则和词法作用域规则。 换句话说：为什么要自找麻烦使用 this 风格的代码模式呢？把它和词法作用域结合在一起非常让人头疼。在代码中使用两种风格其中的一种是非常自然的事情，但是不要将两种风格混在一起使用。 另一个导致箭头函数不够理想的原因是它们是匿名而非具名的。具名函数比匿名函数更可取的原因参见第 3 章。 在我看来，解决这个“问题”的另一个更合适的办法是正确使用和包含 this 机制。12345678910111213var obj = &#123; count: 0, cool: function coolFn() &#123; if (this.count &lt; 1) &#123; setTimeout( function timer()&#123; this.count++; // this 是安全的 // 因为 bind(..) console.log( "more awesome" ); &#125;.bind( this ), 100 ); // look, bind()! &#125; &#125;&#125;;obj.cool(); // 更酷了。 无论你是喜欢箭头函数中 this 词法的新行为模式，还是喜欢更靠得住的 bind()，都需要注意箭头函数不仅仅意味着可以少写代码。 它们之间有意为之的不同行为需要我们理解和掌握，才能正确地使用它们。 现在我们已经完全理解了词法作用域（还有闭包），理解 this 词法是小菜一碟！]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>你不知道的JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的JS总结-作用域和闭包(一)]]></title>
    <url>%2F2018%2F02%2F05%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E6%80%BB%E7%BB%93-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[这几天读了下《你不知道的JavaScript（上卷）》,对于书中作用域和闭包的知识点做一下总结 第 1 章 作用域是什么要了解作用域的规则，首先需要了解简单的编译原理。 编译原理尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。 在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。 分词/词法分析（Tokenizing/Lexing） 这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。如：var a = 2; =&gt; var、a、=、2 、; 解析/语法分析（Parsing） 这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。 代码生成 将 AST 转换为可执行代码的过程称被称为代码生成。 理解作用域 需要理解三个处理过程中的参与者： 引擎 从头到尾负责整个 JavaScript 程序的编译及执行过程。 编译器 引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。 作用域 引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 例子: var a = 2; 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。 在赋值中，对于引擎来讲，引擎会为变量 a 进行 LHS 查询。另外一个查找的类型叫作 RHS。 RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。RHS 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。 你可以将 RHS 理解成 retrieve his source value（取到它的源值）。 作用域嵌套当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。 不管是LHS 和 RHS都需要对作用域按照上图进行查找。一旦抵达全局作用域，无论你有没有找到所需变量，查找过程都会终止。 异常LHS和RHS,在最终没有找到变量的时候处理方式会有差异: RHS 抛出异常ReferenceError LHS 在严格模式，抛出异常ReferenceError,正常模式，会创建一个具有该名称的变量，并将其返还给引擎。 RHS 中，如果找到一个变量对这个变量进行不合理的操作。会抛出TypeError ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了。 小结作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。 JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声明会被分解成两个独立的步骤： 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。 接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。 LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。 第 2 章 词法作用域作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的 词法作用域 ，我们会对这种作用域进行深入讨论。另外一种叫作 动态作用域，仍有一些编程语言在使用（比如 Bash 脚本、Perl 中的一些模式等）。 词法阶段第 1 章介绍过，大部分标准语言编译器的第一个工作阶段叫作词法化（也叫单词化）。回忆一下，词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。 简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。 12345678function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log( a, b, c ); &#125; bar( b * 3 );&#125;foo( 2 ); // 2, 4, 12 这个例子中有三个逐级嵌套的作用域。为了帮助理解，可以将它们想象成几个逐级包含的气泡。 包含着整个全局作用域，其中只有一个标识符：foo。 包含着 foo 所创建的作用域，其中有三个标识符：a、bar 和 b。 包含着 bar 所创建的作用域，其中只有一个标识符：c 没有任何函数的气泡可以（部分地）同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样。 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“ 遮蔽效应 ”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 欺骗词法如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（也可以说欺骗）词法作用域呢？ JavaScript 中有两种机制来实现这个目的 eval JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。 withJavaScript 中另一个难以掌握（并且现在也不推荐使用）的用来欺骗词法作用域的功能是with 关键字。 性能这是我们抛弃上述两个方法的主要原因， JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。 但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。 如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。 小结词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。 JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。 这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。 第 3 章 函数作用域和块作用域函数中的作用域123456789function foo(a) &#123; var b = 2; // 一些代码 function bar() &#123; // ... &#125; // 更多的代码 var c = 3;&#125; 无论标识符声明出现在作用域中的何处，这个标识符所代表的变量或函数都将附属于所处作用域的气泡。 在下一章提升中会着重介绍。 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用JavaScript 变量可以根据需要改变值类型的“动态”特性。 隐藏内部实现对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了。 有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。 123456789function doSomething(a) &#123; b = a + doSomethingElse( a * 2 ); console.log( b * 3 );&#125;function doSomethingElse(a) &#123; return a - 1;&#125;var b;doSomething( 2 ); // 15 上述的例子中，就是一个反例，将应该私有的变量b和函数doSomethingElse(..)暴露给了外部作用域。 123456789function doSomething(a) &#123; function doSomethingElse(a) &#123; return a - 1; &#125; var b; b = a + doSomethingElse( a * 2 ); console.log( b * 3 );&#125;doSomething( 2 ); // 15 修改后的代码，b和 doSomethingElse(..)都无法从外部被访问。 规避冲突12345678910function foo() &#123; function bar(a) &#123; i = 3; // 修改 for 循环所属作用域中的 i console.log( a + i ); &#125; for (var i=0; i&lt;10; i++) &#123; bar( i * 2 ); // 糟糕，无限循环了！ &#125;&#125;foo(); bar(..) 内部的赋值表达式 i = 3 意外地覆盖了声明在 foo(..) 内部 for 循环中的 i。在这个例子中将会导致无限循环，因为 i 被固定设置为 3，永远满足小于 10 这个条件。 这里我们能选用两种方法，一种新声明一个本地变量，var i = 3;。另一种，新添加一个标识符名称，比如 var j = 3。 软件设计在某种情况下可能自然而然地要求使用同样的标识符名称，所以通过作用域来“隐藏”内部声明是唯一的最佳选择。 全局命名空间变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。 这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。123456789var MyReallyCoolLibrary = &#123; awesome: "stuff", doSomething: function() &#123; // ... &#125;, doAnotherThing: function() &#123; // ... &#125;&#125;; 模块管理这种避免冲突的方法和现代的木块机制很接近，从众多的模块管理器挑选一个使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。 显而易见，这些工具并没有能够违反词法作用域规则的“神奇”功能。它们只是利用作用域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突。 函数作用域在前面我们知道了，在任意代码片段外部添加包装函数，可以讲变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。 这个方法也有不理想之处。我们必须声明一个具名函数，这也就意味着，这个具名函数的名称已经“污染”了所在作用域。其次，必须显示的调用这个具名函数，才能运行其中的代码。 如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想。 JS中的同时解决两种问题的方案：1234567var a = 2;(function foo()&#123; // &lt;-- 添加这一行 var a = 3; console.log( a ); // 3&#125;)(); // &lt;-- 以及这一行console.log( a ); // 2 包装函数的声明以 (function… 而不仅是以 function… 开始。尽管看上去这并不是一个很显眼的细节，但实际上却是非常重要的区别。函数会被当作函数表达式而不是一个标准的函数声明来处理。其实就是立即执行了。 区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。 函数声明 和 函数表达式 之间最重要的区别是它们的名称标识符将会绑定在何处。 (function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。 匿名和具名123setTimeout( function() &#123;console.log("I waited 1 second!");&#125;, 1000 ); 上述的定时的代码片段，我们很熟悉，这就是 匿名函数表达式 , 因为function().. 没有名称标识符。 匿名函数书写起来简单便捷，不过有几个缺点需要考虑。 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。 立即执行函数表达式IIFE, 代表立即执行函数表达式（Immediately Invoked Function Expression）； 函数名对于IIFE不是必需的，IIFE 最常见的用法是使用一个匿名函数表达式。 IIFE 的一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。 IIFE 另一个场景，解决undefined 标识符的默认值被错误覆盖导致的异常（虽然不常见）。 IIFE 是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE执行之后当作参数传递进去。 块作用域123for (var i=0; i&lt;10; i++) &#123; console.log( i );&#125; 我们在 for 循环的头部直接定义了变量 i，通常是因为只想在 for 循环内部的上下文中使用 i，而忽略了 i 会被绑定在外部作用域（函数或全局）中的事实。 123456var foo = true;if (foo) &#123; var bar = foo * 2; bar = something( bar ); console.log( bar );&#125; 使用 var 声明变量时，它写在哪里都是一样的，因为它们最终都会属于外部作用域。这段代码是为了风格更易读而伪装出的形式上的块作用域，如果使用这种形式，要确保没在作用域其他地方意外地使用 bar 只能依靠自觉性。 块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息。实现方法： with try/catch catch分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。 let let这里我们着重介绍下，let的实现原理。 let关键字可以将变量绑定到所在的任意作用域中，通常是{ .. } 内部.换句话说，let为其声明的变量隐式地了所在的块作用域。1234567var foo = true;if (foo) &#123; let bar = foo * 2; bar = something( bar ); console.log( bar );&#125;console.log( bar ); // ReferenceError 用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。 在开发和修改代码的过程中，如果没有密切关注哪些块作用域中有绑定的变量，并且习惯性地移动这些块或者将其包含在其他的块中，就会导致代码变得混乱。 显示的块作用域，可以解决上述问题。123456789var foo = true;if (foo) &#123; &#123; // &lt;-- 显式的快 let bar = foo * 2; bar = something( bar ); console.log( bar ); &#125;&#125;console.log( bar ); // ReferenceError 例子中，我们在 if 声明内部显式地创建了一个块，如果需要对其进行重构，整个块都可以被方便地移动而不会对外部 if 声明的位置和语义产生任何影响 垃圾收集 另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。通过块作用域，能够让引擎知道我们执行后的代码片段不需要继续保存。 let循环 1234for (let i=0; i&lt;10; i++) &#123; console.log( i );&#125;console.log( i ); // ReferenceError for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。 下面通过另一种方式来说明每次迭代时进行重新绑定的行为： 1234567&#123; let j; for (j=0; j&lt;10; j++) &#123; let i = j; // 每个迭代重新绑定！ console.log( i ); &#125;&#125; const 同样可以用来创建块作用域变量，但其值是固定的（常量）。 小结函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。 从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。 在 ES6 中引入了 let 关键字（var 关键字的表亲），用来在任意代码块中声明变量。if(..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块中。 有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。]]></content>
      <categories>
        <category>JS基础</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>你不知道的JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之Promise（一）]]></title>
    <url>%2F2018%2F01%2F18%2FES6%E4%B9%8BPromise%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Promise含义javaScript异步最常用的方式就是通过成功的回调函数进行对返回过来的参数进行逻辑处理。一般的回调函数我们都会使用嵌套回调或者链式回调。这样的写法会影响后续的开发。 会产生以下的问题：1.当采用嵌套回调的时候，会导致层级他多，不利于维护； 2.所以我们又采用了链式回调，对嵌套回调进行拆分，拆分后的函数间的耦合度很高，容易产生BUG； 3.如果需要传递参数，函数之间的关联性会更高，参数需要校验，或者多参的时候，要进行多次判断提高代码的合理性； 4.如果回调函数的参数要提交给第三方库或者插件（支付，地图，第三方API，接口），就要考虑一些不可控因素； 调用的时间太早 调用的时间太晚 多次调用，或者调用少 在这个背景下，ES6诞生之时社区最早提出了更合理更强大的解决办法，ES6将其纳入写进了语言标准，统一了用法，原生提供了Promise对象。 什么是Promise1234567891011121314设想一下这个场景，我去一家螺丝粉店，交给收银员老板娘10元，下单买一个螺蛳粉，下单付款。到这里，我已经发出了一个请求（购买了一份螺丝粉），启动了一次交易。但是厨房（系统）需要制作的时间（响应的时间），我不能马上得到螺蛳粉吃，收银员老板娘会给一张小票替代螺丝粉，这张小票就是一个承诺（Promise），保证我最后能得到这份螺蛳粉。所以我需要好好的保留的这张小票，对我来说，小票就是螺蛳粉，虽然这张小票不能吃，我需要等待螺蛳粉做好，等待收银员老板娘叫号通知我。在等待的过程中，我可以做别的事情，如：刷微博，撩老板娘……（loading等操作），pending（进行中）；收银员老板娘终于叫到我的号了，我就用这张小票去换螺丝粉；当然还有一种情况，当我去柜台取螺蛳粉的时候，收银员告诉我螺蛳粉卖光了，做螺蛳粉的师傅受伤了等等原因，导致了我无法得到这个螺蛳粉；虽然我有小票（承诺）Promise，但是可能得到螺蛳粉 fulfilled（已成功），可能得不到螺蛳粉 rejected（已失败）；我由等待螺蛳粉变成了等到或者等不到，这个过程不可逆。 上面很形象的介绍了promise，上面的等待螺蛳粉和得到螺蛳粉，螺蛳粉卖光了，得不到螺蛳粉，分别对应promise的三种状态三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）(一旦状态改变，就不会再变)。 回调函数调用过早调用过早就是将异步函数作为同步处理了， 我们之前说过，javascript以单线程同步的方式执行主线程，遇到异步会将异步函数放入到任务队列中， 当主线程执行完毕，会循环执行任务队列中的函数，也就是事件循环，直到任务队列为空。 事件循环和任务队列事件循环就像是一个游乐场，玩过一个游戏后，你需要重新排到队尾才能再玩一次 任务队列就是，在你玩过一个游戏后，可以插队接着玩 果断举一个栗子🌰：12345678const promise = new Promise((resolve, reject) =&gt; &#123; resolve("成功啦") &#125;); promise.then(res =&gt; &#123; console.log(res); console.log("我是异步执行的"); &#125;) console.log('我在主线程'); 输出顺序123//我在主线程//成功啦//我是异步执行的 直接手动是promise的状态切为成功状态，console.log(“我是异步执行的”);这段代码也是异步执行的提供给then()的回调永远都是异步执行的，所以promise中不会出现回调函数过早执行的情况。 回调函数调用过晚或不被调用回调函数调用过晚的处理原理和调用过早很类似， 在promise的then()中存放着异步函数，所有的异步都存在于js的任务队列中，当js的主线程执行完毕后，会依次执行任务队列中的内容，不会出现执行过晚的情况 果断举一个栗子🌰：123const promise = new Promise((resolve, reject) =&gt; resolve('成功啦'))promise.then(s =&gt; console.log(s));console.log('我在主线程'); 成功状态的输出12//我在主线程//成功啦 成功状态下回调被调用继续看一下失败的回调123const promise = new Promise((resolve, reject) =&gt; reject('失败啦'))promise.then(null, s =&gt; console.log(s));console.log('我在主线程'); 失败状态的输出12//我在主线程//失败啦 回调函数调用次数过多或者过少调用次数过多我们之前说了promise有三种状态pending（进行中）、fulfilled（已成功）和rejected（已失败）状态一旦状态改变，就不会再变一个栗子123456789101112const promise = new Promise((resolve, reject) =&gt; &#123; reject('失败啦') resolve('成功啦')&#125;);promise.then(res =&gt; &#123; console.log(`我是异步执行的成功:$&#123;res&#125;`);&#125;,err =&gt;&#123; console.log(`我是异步执行的失败:$&#123;err&#125;`);&#125;).catch(err =&gt; &#123; console.log(err);&#125;)console.log('我在主线程'); 输出 12//我在主线程//我是异步执行的失败:失败啦 当状态变为失败时，就不会再变为成功，成功的函数也不会执行，反之亦然。 Promise用法会封装请看下一篇。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript高级]]></title>
    <url>%2F2018%2F01%2F01%2FjavaScript%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[一些javaScript知识点总结 目标 理解面向对象开发思想 掌握 JavaScript 面向对象开发相关模式 掌握在 JavaScript 中使用正则表达式 基本概念复习 由于 JavaScript 高级还是针对 JavaScript 语言本身的一个进阶学习，所以在开始之前我们先对以前所学过的 JavaScript 相关知识点做一个快速复习总结。 重新介绍 JavaScriptJavaScript 是什么 解析执行：轻量级解释型的，或是 JIT 编译型的程序设计语言 语言特点：动态，头等函数 (First-class Function) 又称函数是 JavaScript 中的一等公民 执行环境：在宿主环境（host environment）下运行，浏览器是最常见的 JavaScript 宿主环境 但是在很多非浏览器环境中也使用 JavaScript ，例如 node.js 编程范式：基于原型、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如：函数式编程）编程风格 JavaScript 的组成 组成部分 说明 Ecmascript 描述了该语言的语法和基本对象 DOM 描述了处理网页内容的方法和接口 BOM 描述了与浏览器进行交互的方法和接口 JavaScript 可以做什么 Any application that can be written in JavaScript, will eventually be written in JavaScript.凡是能用 JavaScript 写出来的，最终都会用 JavaScript 写出来 知乎 - JavaScript 能做什么，该做什么？ 最流行的编程语言 JavaScript 能做什么？ JavaScript 发展历史 JavaScript 标准参考教程 - JavaScript 语言的历史 JavaScript 的诞生 JavaScript 与 Ecmascript 的关系 JavaScript 与 Java 的关系 JavaScript 的版本 JavaScript 周边大事记 小结基本概念 本小节快速过即可，主要是对学过的内容做知识点梳理。 语法 区分大小写 标识符 注释 严格模式 语句 关键字和保留字 变量 数据类型 typeof 操作符 Undefined Null Boolean Number String Object 操作符 流程控制语句 函数 JavaScript 中的数据类型JavaScript 有 5 种简单数据类型：Undefined、Null、Boolean、Number、String 和 1 种复杂数据类型 Object 。 基本类型（值类型） Undefined Null Boolean Number String 复杂类型（引用类型） Object Array Date RegExp Function 基本包装类型 Boolean Number String 单体内置对象 Global Math 类型检测 typeof instanceof Object.prototype.toString.call() 值类型和引用类型在内存中的存储方式（画图说明） 值类型按值存储 引用类型按引用存储 值类型复制和引用类型复制（画图说明） 值类型按值复制 引用类型按引用复制 值类型和引用类型参数传递（画图说明） 值类型按值传递 引用类型按引用传递 值类型与引用类型的差别 基本类型在内存中占据固定大小的空间，因此被保存在栈内存中 从一个变量向另一个变量复制基本类型的值，复制的是值的副本 引用类型的值是对象，保存在堆内存 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针 从一个变量向另一个变量复制引用类型的值的时候，复制是引用指针，因此两个变量最终都指向同一个对象 小结 类型检测方式 值类型和引用类型的存储方式 值类型复制和引用类型复制 方法参数中 值类型数据传递 和 引用类型数据传递 JavaScript 执行过程JavaScript 运行分为两个阶段： 预解析 全局预解析（所有变量和函数声明都会提前；同名的函数和变量函数的优先级高） 函数内部预解析（所有的变量、函数和形参都会参与预解析） 函数 形参 普通变量 执行 先预解析全局作用域，然后执行全局作用域中的代码，在执行全局代码的过程中遇到函数调用就会先进行函数预解析，然后再执行函数内代码。 JavaScript 面向对象编程面向对象介绍什么是对象 Everything is object （万物皆对象） 对象到底是什么，我们可以从两次层次来理解。 (1) 对象是单个事物的抽象。 一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。 (2) 对象是一个容器，封装了属性（property）和方法（method）。 属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 在实际开发中，对象是一个抽象的概念，可以将其简单理解为：数据集或功能集。 ECMAScript-262 把对象定义为：无序属性的集合，其属性可以包含基本值、对象或者函数。严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。 提示：每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型。 什么是面向对象 面向对象不是新的东西，它只是过程式代码的一种高度封装，目的在于提高代码的开发效率和可维护性。 面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。 面向对象与面向过程： 面向过程就是亲力亲为，事无巨细，面面俱到，步步紧跟，有条不紊 面向对象就是找一个对象，指挥得结果 面向对象将执行者转变成指挥者 面向对象不是面向过程的替代，而是面向过程的封装 面向对象的特性： 封装性 继承性 [多态性] 扩展阅读： 维基百科 - 面向对象程序设计 知乎：如何用一句话说明什么是面向对象思想？ 知乎：什么是面向对象编程思想？ 程序中面向对象的基本体现在 JavaScript 中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（ Class ）的概念。 我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。 假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个对象表示： 12var std1 = &#123; name: 'Michael', score: 98 &#125;var std2 = &#123; name: 'Bob', score: 81 &#125; 而处理学生成绩可以通过函数实现，比如打印学生的成绩： 123function printScore (student) &#123; console.log('姓名：' + student.name + ' ' + '成绩：' + student.score)&#125; 如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是 Student 这种数据类型应该被视为一个对象，这个对象拥有 name 和 score 这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个 printScore 消息，让对象自己把自己的数据打印出来。 抽象数据行为模板（Class）： 12345678function Student (name, score) &#123; this.name = name this.score = score&#125;Student.prototype.printScore = function () &#123; console.log('姓名：' + this.name + ' ' + '成绩：' + this.score)&#125; 根据模板创建具体实例对象（Instance）： 12var std1 = new Student('Michael', 98)var std2 = new Student('Bob', 81) 实例对象具有自己的具体行为（给对象发消息）： 12std1.printScore() // =&gt; 姓名：Michael 成绩：98std2.printScore() // =&gt; 姓名：Bob 成绩 81 面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class 是一种抽象概念，比如我们定义的 Class——Student ，是指学生这个概念，而实例（Instance）则是一个个具体的 Student ，比如， Michael 和 Bob 是两个具体的 Student 。 所以，面向对象的设计思想是： 抽象出 Class 根据 Class 创建 Instance 指挥 Instance 得结果 面向对象的抽象程度又比函数要高，因为一个 Class 既包含数据，又包含操作数据的方法。 创建对象简单方式我们可以直接通过 new Object() 创建： 1234567var person = new Object()person.name = 'Jack'person.age = 18person.sayName = function () &#123; console.log(this.name)&#125; 每次创建通过 new Object() 比较麻烦，所以可以通过它的简写形式对象字面量来创建： 1234567var person = &#123; name: 'Jack', age: 18, sayName: function () &#123; console.log(this.name) &#125;&#125; 对于上面的写法固然没有问题，但是假如我们要生成两个 person 实例对象呢？ 123456789101112131415var person1 = &#123; name: 'Jack', age: 18, sayName: function () &#123; console.log(this.name) &#125;&#125;var person2 = &#123; name: 'Mike', age: 16, sayName: function () &#123; console.log(this.name) &#125;&#125; 通过上面的代码我们不难看出，这样写的代码太过冗余，重复性太高。 简单方式的改进：工厂函数我们可以写一个函数，解决代码重复问题： 123456789function createPerson (name, age) &#123; return &#123; name: name, age: age, sayName: function () &#123; console.log(this.name) &#125; &#125;&#125; 然后生成实例对象： 12var p1 = createPerson('Jack', 18)var p2 = createPerson('Mike', 18) 这样封装确实爽多了，通过工厂模式我们解决了创建多个相似对象代码冗余的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。 构造函数内容引导： 构造函数语法 分析构造函数 构造函数和实例对象的关系 实例的 constructor 属性 instanceof 操作符 普通函数调用和构造函数调用的区别 构造函数的返回值 构造函数的静态成员和实例成员 函数也是对象 实例成员 静态成员 构造函数的问题 更优雅的工厂函数：构造函数一种更优雅的工厂函数就是下面这样，构造函数： 12345678910111213function Person (name, age) &#123; this.name = name this.age = age this.sayName = function () &#123; console.log(this.name) &#125;&#125;var p1 = new Person('Jack', 18)p1.sayName() // =&gt; Jackvar p2 = new Person('Mike', 23)p2.sayName() // =&gt; Mike 解析构造函数代码的执行在上面的示例中，Person() 函数取代了 createPerson() 函数，但是实现效果是一样的。这是为什么呢？ 我们注意到，Person() 中的代码与 createPerson() 有以下几点不同之处： 没有显示的创建对象 直接将属性和方法赋给了 this 对象 没有 return 语句 函数名使用的是大写的 Person 而要创建 Person 实例，则必须使用 new 操作符。以这种方式调用构造函数会经历以下 4 个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） 执行构造函数中的代码 返回新对象 下面是具体的伪代码： 12345678910111213141516function Person (name, age) &#123; // 当使用 new 操作符调用 Person() 的时候，实际上这里会先创建一个对象 // var instance = &#123;&#125; // 然后让内部的 this 指向 instance 对象 // this = instance // 接下来所有针对 this 的操作实际上操作的就是 instance this.name = name this.age = age this.sayName = function () &#123; console.log(this.name) &#125; // 在函数的结尾处会将 this 返回，也就是 instance // return this&#125; 构造函数和实例对象的关系使用构造函数的好处不仅仅在于代码的简洁性，更重要的是我们可以识别对象的具体类型了。在每一个实例对象中同时有一个 constructor 属性，该属性指向创建该实例的构造函数： 123console.log(p1.constructor === Person) // =&gt; trueconsole.log(p2.constructor === Person) // =&gt; trueconsole.log(p1.constructor === p2.constructor) // =&gt; true 对象的 constructor 属性最初是用来标识对象类型的，但是，如果要检测对象的类型，还是使用 instanceof 操作符更可靠一些： 12console.log(p1 instanceof Person) // =&gt; trueconsole.log(p2 instanceof Person) // =&gt; true 总结： 构造函数是根据具体的事物抽象出来的抽象模板 实例对象是根据抽象的构造函数模板得到的具体实例对象 每一个实例对象都具有一个 constructor 属性，指向创建该实例的构造函数 注意： constructor 是实例的属性的说法不严谨，具体后面的原型会讲到 可以通过实例的 constructor 属性判断实例和构造函数之间的关系 注意：这种方式不严谨，推荐使用 instanceof 操作符，后面学原型会解释为什么 构造函数的问题使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题： 1234567891011function Person (name, age) &#123; this.name = name this.age = age this.type = 'human' this.sayHello = function () &#123; console.log('hello ' + this.name) &#125;&#125;var p1 = new Person('lpz', 18)var p2 = new Person('Jack', 16) 在该示例中，从表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type 和 sayHello 都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存，如果实例对象很多，会造成极大的内存浪费。 1console.log(p1.sayHello === p2.sayHello) // =&gt; false 对于这种问题我们可以把需要共享的函数定义到构造函数外部： 123456789101112131415function sayHello = function () &#123; console.log('hello ' + this.name)&#125;function Person (name, age) &#123; this.name = name this.age = age this.type = 'human' this.sayHello = sayHello&#125;var p1 = new Person('lpz', 18)var p2 = new Person('Jack', 16)console.log(p1.sayHello === p2.sayHello) // =&gt; true 这样确实可以了，但是如果有多个需要共享的函数的话就会造成全局命名空间冲突的问题。 你肯定想到了可以把多个函数放到一个对象中用来避免全局命名空间冲突的问题： 12345678910111213141516171819202122var fns = &#123; sayHello: function () &#123; console.log('hello ' + this.name) &#125;, sayAge: function () &#123; console.log(this.age) &#125;&#125;function Person (name, age) &#123; this.name = name this.age = age this.type = 'human' this.sayHello = fns.sayHello this.sayAge = fns.sayAge&#125;var p1 = new Person('lpz', 18)var p2 = new Person('Jack', 16)console.log(p1.sayHello === p2.sayHello) // =&gt; trueconsole.log(p1.sayAge === p2.sayAge) // =&gt; true 至此，我们利用自己的方式基本上解决了构造函数的内存浪费问题。但是代码看起来还是那么的格格不入，那有没有更好的方式呢？ 小结 构造函数语法 分析构造函数 构造函数和实例对象的关系 实例的 constructor 属性 instanceof 操作符 构造函数的问题 原型内容引导： 使用 prototype 原型对象解决构造函数的问题 分析 构造函数、prototype 原型对象、实例对象 三者之间的关系 属性成员搜索原则：原型链 实例对象读写原型对象中的成员 原型对象的简写形式 原生对象的原型 Object Array String … 原型对象的问题 构造的函数和原型对象使用建议 更好的解决方案： prototypeJavascript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。 这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 prototype 对象上。 1234567891011121314151617function Person (name, age) &#123; this.name = name this.age = age&#125;console.log(Person.prototype)Person.prototype.type = 'human'Person.prototype.sayName = function () &#123; console.log(this.name)&#125;var p1 = new Person(...)var p2 = new Person(...)console.log(p1.sayName === p2.sayName) // =&gt; true 这时所有实例的 type 属性和 sayName() 方法，其实都是同一个内存地址，指向 prototype 对象，因此就提高了运行效率。 构造函数、实例、原型三者之间的关系任何函数都具有一个 prototype 属性，该属性是一个对象。 123456function F () &#123;&#125;console.log(F.prototype) // =&gt; objectF.prototype.sayHi = function () &#123; console.log('hi!')&#125; 构造函数的 prototype 对象默认都有一个 constructor 属性，指向 prototype 对象所在函数。 1console.log(F.constructor === F) // =&gt; true 通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针 __proto__。 12var instance = new F()console.log(instance.__proto__ === F.prototype) // =&gt; true __proto__ 是非标准属性。 实例对象可以直接访问原型对象成员。 1instance.sayHi() // =&gt; hi! 总结： 任何函数都具有一个 prototype 属性，该属性是一个对象 构造函数的 prototype 对象默认都有一个 constructor 属性，指向 prototype 对象所在函数 通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针 __proto__ 所有实例都直接或间接继承了原型对象的成员 属性成员的搜索原则：原型链了解了 构造函数-实例-原型对象 三者之间的关系后，接下来我们来解释一下为什么实例对象可以访问原型对象中的成员。 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性 搜索首先从对象实例本身开始 如果在实例中找到了具有给定名字的属性，则返回该属性的值 如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性 如果在原型对象中找到了这个属性，则返回该属性的值 也就是说，在我们调用 person1.sayName() 的时候，会先后执行两次搜索： 首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。 ”然后，它继续搜索，再问：“ person1 的原型有 sayName 属性吗？”答：“有。 ”于是，它就读取那个保存在原型对象中的函数。 当我们调用 person2.sayName() 时，将会重现相同的搜索过程，得到相同的结果。 而这正是多个对象实例共享原型所保存的属性和方法的基本原理。 总结： 先在自己身上找，找到即返回 自己身上找不到，则沿着原型链向上查找，找到即返回 如果一直到原型链的末端还没有找到，则返回 undefined 实例对象读写原型对象成员读取： 先在自己身上找，找到即返回 自己身上找不到，则沿着原型链向上查找，找到即返回 如果一直到原型链的末端还没有找到，则返回 undefined 值类型成员写入（实例对象.值类型成员 = xx）： 当实例期望重写原型对象中的某个普通数据成员时实际上会把该成员添加到自己身上 也就是说该行为实际上会屏蔽掉对原型对象成员的访问 引用类型成员写入（实例对象.引用类型成员 = xx）： 同上 复杂类型修改（实例对象.成员.xx = xx）： 同样会先在自己身上找该成员，如果自己身上找到则直接修改 如果自己身上找不到，则沿着原型链继续查找，如果找到则修改 如果一直到原型链的末端还没有找到该成员，则报错（实例对象.undefined.xx = xx） 更简单的原型语法我们注意到，前面例子中每添加一个属性和方法就要敲一遍 Person.prototype 。为减少不必要的输入，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象： 1234567891011function Person (name, age) &#123; this.name = name this.age = age&#125;Person.prototype = &#123; type: 'human', sayHello: function () &#123; console.log('我叫' + this.name + '，我今年' + this.age + '岁了') &#125;&#125; 在该示例中，我们将 Person.prototype 重置到了一个新的对象。这样做的好处就是为 Person.prototype 添加成员简单了，但是也会带来一个问题，那就是原型对象丢失了 constructor 成员。 所以，我们为了保持 constructor 的指向正确，建议的写法是： 123456789101112function Person (name, age) &#123; this.name = name this.age = age&#125;Person.prototype = &#123; constructor: Person, // =&gt; 手动将 constructor 指向正确的构造函数 type: 'human', sayHello: function () &#123; console.log('我叫' + this.name + '，我今年' + this.age + '岁了') &#125;&#125; 原生对象的原型 所有函数都有 prototype 属性对象。 Object.prototype Function.prototype Array.prototype String.prototype Number.prototype Date.prototype … 练习：为数组对象和字符串对象扩展原型方法。 原型对象的问题 共享数组 共享对象 如果真的希望可以被实例对象之间共享和修改这些共享数据那就不是问题。但是如果不希望实例之间共享和修改这些共享数据则就是问题。 一个更好的建议是，最好不要让实例之间互相共享这些数组或者对象成员，一旦修改的话会导致数据的走向很不明确而且难以维护。 原型对象使用建议 私有成员（一般就是非函数成员）放到构造函数中 共享成员（一般就是函数）放到原型对象中 如果重置了 prototype 记得修正 constructor 的指向 案例：随机方块面向对象游戏案例：贪吃蛇案例相关源码以上传到 GitHub ：https://github.com/lipengzhou/new-snake 案例介绍游戏演示在线演示地址：贪吃蛇 案例目标游戏的目的是用来体会js高级语法的使用 不需要具备抽象对象的能力，使用面向对象的方式分析问题，需要一个漫长的过程。 功能实现搭建页面放一个容器盛放游戏场景 div#map，设置样式 123456#map &#123; width: 800px; height: 600px; background-color: #ccc; position: relative;&#125; 分析对象 游戏对象 蛇对象 食物对象 创建食物对象 Food 属性 x y width height color 方法 render 随机创建一个食物对象，并输出到map上 创建Food的构造函数，并设置属性 1234567891011var position = 'absolute';var elements = [];function Food(x, y, width, height, color) &#123; this.x = x || 0; this.y = y || 0; // 食物的宽度和高度(像素) this.width = width || 20; this.height = height || 20; // 食物的颜色 this.color = color || 'green';&#125; 通过原型设置render方法，实现随机产生食物对象，并渲染到map上 12345678910111213141516Food.prototype.render = function (map) &#123; // 随机食物的位置，map.宽度/food.宽度，总共有多少分food的宽度，随机一下。然后再乘以food的宽度 this.x = parseInt(Math.random() * map.offsetWidth / this.width) * this.width; this.y = parseInt(Math.random() * map.offsetHeight / this.height) * this.height; // 动态创建食物对应的div var div = document.createElement('div'); map.appendChild(div); div.style.position = position; div.style.left = this.x + 'px'; div.style.top = this.y + 'px'; div.style.width = this.width + 'px'; div.style.height = this.height + 'px'; div.style.backgroundColor = this.color; elements.push(div);&#125; 通过自调用函数，进行封装，通过window暴露Food对象 1window.Food = Food; 创建蛇对象 Snake 属性 width 蛇节的宽度 默认20 height 蛇节的高度 默认20 body 数组，蛇的头部和身体，第一个位置是蛇头 direction 蛇运动的方向 默认right 可以是 left top bottom 方法 render 把蛇渲染到map上 Snake构造函数 1234567891011121314var position = 'absolute';var elements = [];function Snake(width, height, direction) &#123; // 设置每一个蛇节的宽度 this.width = width || 20; this.height = height || 20; // 蛇的每一部分, 第一部分是蛇头 this.body = [ &#123;x: 3, y: 2, color: 'red'&#125;, &#123;x: 2, y: 2, color: 'red'&#125;, &#123;x: 1, y: 2, color: 'red'&#125; ]; this.direction = direction || 'right';&#125; render方法 12345678910111213Snake.prototype.render = function(map) &#123; for(var i = 0; i &lt; this.body.length; i++) &#123; var obj = this.body[i]; var div = document.createElement('div'); map.appendChild(div); div.style.left = obj.x * this.width + 'px'; div.style.top = obj.y * this.height + 'px'; div.style.position = position; div.style.backgroundColor = obj.color; div.style.width = this.width + 'px'; div.style.height = this.height + 'px'; &#125;&#125; 在自调用函数中暴露Snake对象 1window.Snake = Snake; 创建游戏对象游戏对象，用来管理游戏中的所有对象和开始游戏 Game 属性 food snake map 方法 start 开始游戏（绘制所有游戏对象） 构造函数 1234567891011121314function Game(map) &#123; this.food = new Food(); this.snake = new Snake(); this.map = map;&#125;``` - 开始游戏，渲染食物对象和蛇对象```jsGame.prototype.start = function () &#123; this.food.render(this.map); this.snake.render(this.map);&#125; 游戏的逻辑写蛇的move方法 在蛇对象(snake.js)中，在Snake的原型上新增move方法 让蛇移动起来，把蛇身体的每一部分往前移动一下 蛇头部分根据不同的方向决定 往哪里移动 1234567891011121314151617181920212223Snake.prototype.move = function (food, map) &#123; // 让蛇身体的每一部分往前移动一下 var i = this.body.length - 1; for(; i &gt; 0; i--) &#123; this.body[i].x = this.body[i - 1].x; this.body[i].y = this.body[i - 1].y; &#125; // 根据移动的方向，决定蛇头如何处理 switch(this.direction) &#123; case 'left': this.body[0].x -= 1; break; case 'right': this.body[0].x += 1; break; case 'top': this.body[0].y -= 1; break; case 'bottom': this.body[0].y += 1; break; &#125;&#125; 在game中测试 12this.snake.move(this.food, this.map);this.snake.render(this.map); 让蛇自己动起来 私有方法 1234什么是私有方法？ 不能被外部访问的方法如何创建私有方法？ 使用自调用函数包裹 在game.js中 添加runSnake的私有方法，开启定时器调用蛇的move和render方法，让蛇动起来 判断蛇是否撞墙 1234567891011121314151617181920212223function runSnake() &#123; var timerId = setInterval(function() &#123; this.snake.move(this.food, this.map); // 在渲染前，删除之前的蛇 this.snake.render(this.map); // 判断蛇是否撞墙 var maxX = this.map.offsetWidth / this.snake.width; var maxY = this.map.offsetHeight / this.snake.height; var headX = this.snake.body[0].x; var headY = this.snake.body[0].y; if (headX &lt; 0 || headX &gt;= maxX) &#123; clearInterval(timerId); alert('Game Over'); &#125; if (headY &lt; 0 || headY &gt;= maxY) &#123; clearInterval(timerId); alert('Game Over'); &#125; &#125;.bind(that), 150);&#125; 在snake中添加删除蛇的私有方法，在render中调用 12345678910function remove() &#123; // 删除渲染的蛇 var i = elements.length - 1; for(; i &gt;= 0; i--) &#123; // 删除页面上渲染的蛇 elements[i].parentNode.removeChild(elements[i]); // 删除elements数组中的元素 elements.splice(i, 1); &#125;&#125; 在game中通过键盘控制蛇的移动方向 12345678910111213141516171819202122function bindKey() &#123; document.addEventListener('keydown', function(e) &#123; switch (e.keyCode) &#123; case 37: // left this.snake.direction = 'left'; break; case 38: // top this.snake.direction = 'top'; break; case 39: // right this.snake.direction = 'right'; break; case 40: // bottom this.snake.direction = 'bottom'; break; &#125; &#125;.bind(that), false);&#125; 在start方法中调用 1bindKey(); 判断蛇是否吃到食物123456789101112131415161718// 在Snake的move方法中// 在移动的过程中判断蛇是否吃到食物// 如果蛇头和食物的位置重合代表吃到食物// 食物的坐标是像素，蛇的坐标是几个宽度，进行转换var headX = this.body[0].x * this.width;var headY = this.body[0].y * this.height;if (headX === food.x &amp;&amp; headY === food.y) &#123; // 吃到食物，往蛇节的最后加一节 var last = this.body[this.body.length - 1]; this.body.push(&#123; x: last.x, y: last.y, color: last.color &#125;) // 把现在的食物对象删除，并重新随机渲染一个食物对象 food.render(map);&#125; 其它处理把html中的js代码放到index.js中避免html中出现js代码 自调用函数的参数1234(function (window, undefined) &#123; var document = window.document;&#125;(window, undefined)) 传入window对象 将来代码压缩的时候，可以吧 function (window) 压缩成 function (w) 传入undefined 在将来会看到别人写的代码中会把undefined作为函数的参数(当前案例没有使用)因为在有的老版本的浏览器中 undefined可以被重新赋值，防止undefined 被重新赋值 整理代码现在的代码结构清晰，谁出问题就找到对应的js文件即可。通过自调用函数，已经防止了变量命名污染的问题 但是，由于js文件数较多，需要在页面上引用，会产生文件依赖的问题(先引入那个js，再引入哪个js)将来通过工具把js文件合并并压缩。现在手工合并js文件演示 问题1 1234567891011121314// 如果存在多个自调用函数要用分号分割，否则语法错误// 下面代码会报错(function () &#123;&#125;())(function () &#123;&#125;())// 所以代码规范中会建议在自调用函数之前加上分号// 下面代码没有问题;(function () &#123;&#125;());(function () &#123;&#125;()) 问题2 123456789// 当自调用函数 前面有函数声明时，会把自调用函数作为参数// 所以建议自调用函数前，加上;var a = function () &#123; alert('11');&#125; (function () &#123; alert('22');&#125;()) 继承什么是继承 现实生活中的继承 程序中的继承 构造函数的属性继承：借用构造函数12345678910111213function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;function Student (name, age) &#123; // 借用构造函数继承属性成员 Person.call(this, name, age)&#125;var s1 = Student('张三', 18)console.log(s1.type, s1.name, s1.age) // =&gt; human 张三 18 构造函数的原型方法继承：拷贝继承（for-in）12345678910111213141516171819202122function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;Person.prototype.sayName = function () &#123; console.log('hello ' + this.name)&#125;function Student (name, age) &#123; Person.call(this, name, age)&#125;// 原型对象拷贝继承原型对象成员for(var key in Person.prototype) &#123; Student.prototype[key] = Person.prototype[key]&#125;var s1 = Student('张三', 18)s1.sayName() // =&gt; hello 张三 另一种继承方式：原型继承12345678910111213141516171819202122function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;Person.prototype.sayName = function () &#123; console.log('hello ' + this.name)&#125;function Student (name, age) &#123; Person.call(this, name, age)&#125;// 利用原型的特性实现继承Student.prototype = new Person()var s1 = Student('张三', 18)console.log(s1.type) // =&gt; humans1.sayName() // =&gt; hello 张三 函数进阶函数的定义方式 函数声明 函数表达式 new Function 函数声明123function foo () &#123;&#125; 函数表达式123var foo = function () &#123;&#125; 函数声明与函数表达式的区别 函数声明必须有名字 函数声明会函数提升，在预解析阶段就已创建，声明前后都可以调用 函数表达式类似于变量赋值 函数表达式可以没有名字，例如匿名函数 函数表达式没有变量提升，在执行阶段创建，必须在表达式执行之后才可以调用 下面是一个根据条件定义函数的例子： 123456789if (true) &#123; function f () &#123; console.log(1) &#125;&#125; else &#123; function f () &#123; console.log(2) &#125;&#125; 以上代码执行结果在不同浏览器中结果不一致。 不过我们可以使用函数表达式解决上面的问题： 1234567891011var fif (true) &#123; f = function () &#123; console.log(1) &#125;&#125; else &#123; f = function () &#123; console.log(2) &#125;&#125; 函数的调用方式 普通函数 构造函数 对象方法 函数内 this 指向的不同场景函数的调用方式决定了 this 指向的不同： 调用方式 非严格模式 备注 普通函数调用 window 严格模式下是 undefined 构造函数调用 实例对象 原型方法中 this 也是实例对象 对象方法调用 该方法所属对象 紧挨着的对象 事件绑定方法 绑定事件对象 定时器函数 window 这就是对函数内部 this 指向的基本整理，写代码写多了自然而然就熟悉了。 函数也是对象 所有函数都是 Function 的实例 call、apply、bind那了解了函数 this 指向的不同场景之后，我们知道有些情况下我们为了使用某种特定环境的 this 引用，这时候时候我们就需要采用一些特殊手段来处理了，例如我们经常在定时器外部备份 this 引用，然后在定时器函数内部使用外部 this 的引用。然而实际上对于这种做法我们的 JavaScript 为我们专门提供了一些函数方法用来帮我们更优雅的处理函数内部 this 指向问题。这就是接下来我们要学习的 call、apply、bind 三个函数方法。 callcall() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数的列表)。 注意：该方法的作用和 apply() 方法类似，只有一个区别，就是 call() 方法接受的是若干个参数的列表，而 apply() 方法接受的是一个包含多个参数的数组。 语法： 1fun.call(thisArg[, arg1[, arg2[, ...]]]) 参数： thisArg 在 fun 函数运行时指定的 this 值 如果指定了 null 或者 undefined 则内部 this 指向 window arg1, arg2, ... 指定的参数列表 applyapply() 方法调用一个函数, 其具有一个指定的 this 值，以及作为一个数组（或类似数组的对象）提供的参数。 注意：该方法的作用和 call() 方法类似，只有一个区别，就是 call() 方法接受的是若干个参数的列表，而 apply() 方法接受的是一个包含多个参数的数组。 语法： 1fun.apply(thisArg, [argsArray]) 参数： thisArg argsArray apply() 与 call() 非常相似，不同之处在于提供参数的方式。apply() 使用参数数组而不是一组参数列表。例如： 1fun.apply(this, ['eat', 'bananas']) bindbind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。当目标函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 语法： 1fun.bind(thisArg[, arg1[, arg2[, ...]]]) 参数： thisArg 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。 arg1, arg2, … 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 返回值： 返回由指定的this值和初始化参数改造的原函数拷贝。 示例1： 123456789101112131415this.x = 9; var module = &#123; x: 81, getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 返回 81var retrieveX = module.getX;retrieveX(); // 返回 9, 在这种情况下，"this"指向全局作用域// 创建一个新函数，将"this"绑定到module对象// 新手可能会被全局的x变量和module里的属性x所迷惑var boundGetX = retrieveX.bind(module);boundGetX(); // 返回 81 示例2： 12345678910111213141516function LateBloomer() &#123; this.petalCount = Math.ceil(Math.random() * 12) + 1;&#125;// Declare bloom after a delay of 1 secondLateBloomer.prototype.bloom = function() &#123; window.setTimeout(this.declare.bind(this), 1000);&#125;;LateBloomer.prototype.declare = function() &#123; console.log('I am a beautiful flower with ' + this.petalCount + ' petals!');&#125;;var flower = new LateBloomer();flower.bloom(); // 一秒钟后, 调用'declare'方法 小结 call 和 apply 特性一样 都是用来调用函数，而且是立即调用 但是可以在调用函数的同时，通过第一个参数指定函数内部 this 的指向 call 调用的时候，参数必须以参数列表的形式进行传递，也就是以逗号分隔的方式依次传递即可 apply 调用的时候，参数必须是一个数组，然后在执行的时候，会将数组内部的元素一个一个拿出来，与形参一一对应进行传递 如果第一个参数指定了 null 或者 undefined 则内部 this 指向 window bind 可以用来指定内部 this 的指向，然后生成一个改变了 this 指向的新的函数 它和 call、apply 最大的区别是：bind 不会调用 bind 支持传递参数，它的传参方式比较特殊，一共有两个位置可以传递 在 bind 的同时，以参数列表的形式进行传递 在调用的时候，以参数列表的形式进行传递 那到底以谁 bind 的时候传递的参数为准呢还是以调用的时候传递的参数为准 两者合并：bind 的时候传递的参数和调用的时候传递的参数会合并到一起，传递到函数内部 函数的其它成员 arguments 实参集合 caller 函数的调用者 length 形参的个数 name 函数的名称 12345678910111213function fn(x, y, z) &#123; console.log(fn.length) // =&gt; 形参的个数 console.log(arguments) // 伪数组实参参数集合 console.log(arguments.callee === fn) // 函数本身 console.log(fn.caller) // 函数的调用者 console.log(fn.name) // =&gt; 函数的名字&#125;function f() &#123; fn(10, 20, 30)&#125;f() 高阶函数 函数可以作为参数 函数可以作为返回值 作为参数12345678910function eat (callback) &#123; setTimeout(function () &#123; console.log('吃完了') callback() &#125;, 1000)&#125;eat(function () &#123; console.log('去唱歌')&#125;) 作为返回值1234567891011function genFun (type) &#123; return function (obj) &#123; return Object.prototype.toString.call(obj) === type &#125;&#125;var isArray = genFun('[object Array]')var isObject = genFun('[object Object]')console.log(isArray([])) // =&gt; trueconsole.log(isArray(&#123;&#125;)) // =&gt; true 函数闭包1234567891011121314151617function fn () &#123; var count = 0 return &#123; getCount: function () &#123; console.log(count) &#125;, setCount: function () &#123; count++ &#125; &#125;&#125;var fns = fn()fns.getCount() // =&gt; 0fns.setCount()fns.getCount() // =&gt; 1 作用域、作用域链、预解析 全局作用域 函数作用域 没有块级作用域 12345678910&#123; var foo = 'bar'&#125;console.log(foo)if (true) &#123; var a = 123&#125;console.log(a) 作用域链示例代码： 123456789101112131415161718var a = 10function fn () &#123; var b = 20 function fn1 () &#123; var c = 30 console.log(a + b + c) &#125; function fn2 () &#123; var d = 40 console.log(c + d) &#125; fn1() fn2()&#125; 内层作用域可以访问外层作用域，反之不行 什么是闭包闭包就是能够读取其他函数内部变量的函数，由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 “定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的用途： 可以在函数外部读取函数内部成员 让函数内成员始终存活在内存中 一些关于闭包的例子示例1： 123456var arr = [10, 20, 30]for(var i = 0; i &lt; arr.length; i++) &#123; arr[i] = function () &#123; console.log(i) &#125;&#125; 示例2： 12345678console.log(111)for(var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, 0)&#125;console.log(222) 示例3：投票 示例4：判断类型 示例5：沙箱模式 闭包的思考题思考题 1： 1234567891011var name = "The Window";var object = &#123; name: "My Object", getNameFunc: function () &#123; return function () &#123; return this.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()) 思考题 2： 1234567891011var name = "The Window"; var object = &#123; name: "My Object", getNameFunc: function () &#123; var that = this; return function () &#123; return that.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()) 小结函数递归递归执行模型123456789101112131415161718192021222324function fn1 () &#123; console.log(111) fn2() console.log('fn1')&#125;function fn2 () &#123; console.log(222) fn3() console.log('fn2')&#125;function fn3 () &#123; console.log(333) fn4() console.log('fn3')&#125;function fn4 () &#123; console.log(444) console.log('fn4')&#125;fn1() 举个栗子：计算阶乘的递归函数1234567function factorial (num) &#123; if (num &lt;= 1) &#123; return 1 &#125; else &#123; return num * factorial(num - 1) &#125;&#125; 递归应用场景 深拷贝 菜单树 遍历 DOM 树 正则表达式 了解正则表达式基本语法 能够使用JavaScript的正则对象 正则表达式简介什么是正则表达式正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式的作用 给定的字符串是否符合正则表达式的过滤逻辑(匹配) 可以通过正则表达式，从字符串中获取我们想要的特定部分(提取) 强大的字符串替换能力(替换) 正则表达式的特点 灵活性、逻辑性和功能性非常的强 可以迅速地用极简单的方式达到字符串的复杂控制 对于刚接触的人来说，比较晦涩难懂 正则表达式的测试 在线测试正则 工具中使用正则表达式 sublime/vscode/word 演示替换所有的数字 正则表达式的组成 普通字符 特殊字符(元字符)：正则表达式中有特殊意义的字符 示例演示： \d 匹配数字 ab\d 匹配 ab1、ab2 元字符串通过测试工具演示下面元字符的使用 常用元字符串 元字符 说明 \d 匹配数字 \D 匹配任意非数字的字符 \w 匹配字母或数字或下划线 \W 匹配任意不是字母，数字，下划线 \s 匹配任意的空白符 \S 匹配任意不是空白符的字符 . 匹配除换行符以外的任意单个字符 ^ 表示匹配行首的文本(以谁开始) $ 表示匹配行尾的文本(以谁结束) 限定符 限定符 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 其它1234567[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思[^] 匹配除中括号以内的内容\ 转义符| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱() 从两个直接量中选择一个，分组 eg：gr(a|e)y匹配gray和grey[\u4e00-\u9fa5] 匹配汉字 案例验证手机号： 1^\d&#123;11&#125;$ 验证邮编： 1^\d&#123;6&#125;$ 验证日期 2012-5-01 1^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$ 验证邮箱 xxx@itcast.cn： 1^\w+@\w+\.\w+$ 验证IP地址 192.168.1.10 1^\d&#123;1,3&#125;\(.\d&#123;1,3&#125;)&#123;3&#125;$ JavaScript 中使用正则表达式创建正则对象方式1： 12var reg = new Regex('\d', 'i');var reg = new Regex('\d', 'gi'); 方式2： 12var reg = /\d/i;var reg = /\d/gi; 参数 标志 说明 i 忽略大小写 g 全局匹配 gi 全局匹配+忽略大小写 正则匹配1234// 匹配日期var dateStr = '2015-10-10';var reg = /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/console.log(reg.test(dateStr)); 正则提取123456789101112131415161718192021222324252627// 1. 提取工资var str = "张三：1000，李四：5000，王五：8000。";var array = str.match(/\d+/g);console.log(array);// 2. 提取email地址var str = "123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com...";var array = str.match(/\w+@\w+\.\w+(\.\w+)?/g);console.log(array);// 3. 分组提取 // 3. 提取日期中的年部分 2015-5-10var dateStr = '2016-1-5';// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取var reg = /(\d&#123;4&#125;)-\d&#123;1,2&#125;-\d&#123;1,2&#125;/;if (reg.test(dateStr)) &#123; console.log(RegExp.$1);&#125;// 4. 提取邮件中的每一部分var reg = /(\w+)@(\w+)\.(\w+)(\.\w+)?/;var str = "123123@xx.com";if (reg.test(str)) &#123; console.log(RegExp.$1); console.log(RegExp.$2); console.log(RegExp.$3);&#125; 正则替换123456789// 1. 替换所有空白var str = " 123AD asadf asadfasf adf ";str = str.replace(/\s/g,"xx");console.log(str);// 2. 替换所有,|，var str = "abc,efg,123，abc,123，a";str = str.replace(/,|，/g, ".");console.log(str); 案例：表单验证12345QQ号：&lt;input type="text" id="txtQQ"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;邮箱：&lt;input type="text" id="txtEMail"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;手机：&lt;input type="text" id="txtPhone"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;生日：&lt;input type="text" id="txtBirthday"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;姓名：&lt;input type="text" id="txtName"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 12345678910111213141516171819202122232425262728293031323334353637383940//获取文本框var txtQQ = document.getElementById("txtQQ");var txtEMail = document.getElementById("txtEMail");var txtPhone = document.getElementById("txtPhone");var txtBirthday = document.getElementById("txtBirthday");var txtName = document.getElementById("txtName");//txtQQ.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\d&#123;5,12&#125;$/; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = "请输入正确的QQ号"; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125;&#125;;//txtEMailtxtEMail.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\w+@\w+\.\w+(\.\w+)?$/; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = "请输入正确的EMail地址"; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125;&#125;; 表单验证部分，封装成函数： 12345678910111213141516171819var regBirthday = /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/;addCheck(txtBirthday, regBirthday, "请输入正确的出生日期");//给文本框添加验证function addCheck(element, reg, tip) &#123; element.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = tip; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125; &#125;;&#125; 通过给元素增加自定义验证属性对表单进行验证： 1234567&lt;form id="frm"&gt; QQ号：&lt;input type="text" name="txtQQ" data-rule="qq"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 邮箱：&lt;input type="text" name="txtEMail" data-rule="email"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 手机：&lt;input type="text" name="txtPhone" data-rule="phone"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 生日：&lt;input type="text" name="txtBirthday" data-rule="date"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 姓名：&lt;input type="text" name="txtName" data-rule="cn"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;&lt;/form&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 所有的验证规则var rules = [ &#123; name: 'qq', reg: /^\d&#123;5,12&#125;$/, tip: "请输入正确的QQ" &#125;, &#123; name: 'email', reg: /^\w+@\w+\.\w+(\.\w+)?$/, tip: "请输入正确的邮箱地址" &#125;, &#123; name: 'phone', reg: /^\d&#123;11&#125;$/, tip: "请输入正确的手机号码" &#125;, &#123; name: 'date', reg: /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/, tip: "请输入正确的出生日期" &#125;, &#123; name: 'cn', reg: /^[\u4e00-\u9fa5]&#123;2,4&#125;$/, tip: "请输入正确的姓名" &#125;];addCheck('frm');//给文本框添加验证function addCheck(formId) &#123; var i = 0, len = 0, frm =document.getElementById(formId); len = frm.children.length; for (; i &lt; len; i++) &#123; var element = frm.children[i]; // 表单元素中有name属性的元素添加验证 if (element.name) &#123; element.onblur = function () &#123; // 使用dataset获取data-自定义属性的值 var ruleName = this.dataset.rule; var rule =getRuleByRuleName(rules, ruleName); var span = this.nextElementSibling; //判断验证是否成功 if(!rule.reg.test(this.value) )&#123; //验证不成功 span.innerText = rule.tip; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125; &#125; &#125; &#125;&#125;// 根据规则的名称获取规则对象function getRuleByRuleName(rules, ruleName) &#123; var i = 0, len = rules.length; var rule = null; for (; i &lt; len; i++) &#123; if (rules[i].name == ruleName) &#123; rule = rules[i]; break; &#125; &#125; return rule;&#125;]]></content>
      <tags>
        <tag>JS</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[箭头函数]]></title>
    <url>%2F2017%2F12%2F12%2F%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[基本用法1234567var fn = n =&gt; n;//等同于:var fn = function(n) &#123; return n&#125; 箭头函数不需要参数或者多个参数，就用一个圆括号代表参数部分123456789var fn = () =&gt; 10;//等同于:var fn = function () (return 10);var sum = (n1, n2) =&gt; num1 + num2;//等同于:var sum = function(n1, n2) &#123; return n1 + n2&#125;; 如果大括号被解释为代码块，所以箭头函数直接返回一个对象，就需要在代码块外面加上括号1var fn = id =&gt; (&#123; id: id,name: "tony"&#125;); 箭头函数可以与变量结构结合使用。12345const fn = (&#123;f1, f2&#125;) =&gt; f1 + 'number' +f2;//等同于:function fn(obj) &#123; return obj.f1 + 'number' + f2;&#125; 箭头函数最大的有点就是简化回调函数1234567891011// 正常函数写法var a = [1,2,3]a.map(function (n) &#123; return n * 1;&#125;);// 箭头函数写法var a = [1,2,3]a.map(n =&gt; &#123; console.log(n + 1);//1,2,3 return n + 1&#125;) 箭头函数还可以和rest参数结合1234567const nf = (...a) =&gt; &#123; console.log(a);//[3,4,5,6]&#125;;nf(3,4,5,6)const nf = (a1,...a2) =&gt; [a1, a2];nf(3,4,5,6)//[3,[4,5,6]] 需要注意点1.函数体内的this对象，就是定义时候所在的对象，而不是使用时所在的对象。 2.不可以当作构造函数，不能使用new命令行否则抛出一个错误。 3.不可以使用arguments对象，如果参数比较多不想代码冗余，可以使用Rest参数代替。 12345678910111213// 第一点要值得注意，在箭头函数中this对象的指向是固定的，例如如下function fn3() &#123; return &#123; a2: () =&gt; console.log(this), a3: function() &#123; console.log(this); &#125; &#125;&#125;var fn4 = new fn3()fn4.a2() //this = fn3fn4.a3() //this = fn4 箭头函数可以让this指向固定化，这种特性对于封装回调函数很友好。例子如下12345678910111213var fn = &#123; num: 123456, init: function() &#123; document.addEventListener('click', event =&gt; this.doSomething(enent.type),false) &#125;, doSomething: funciotn() &#123; console.log('Handling ' + type + ' for ' + this.id); &#125;&#125; 使用过babel的都知道，es6语法能转换成es5语法（没有使用过可以看下博客下也有一篇对babel说明的文章）12345678910111213141516171819202122//es6写法 function fn3() &#123; return &#123; a2: () =&gt; console.log(this), a3: function() &#123; console.log(this); &#125; &#125; &#125;//使用过babel转换后的写法 function fn3() &#123; var _this = this; return &#123; a2: function a2() &#123; return console.log(_this); &#125;, a3: function a3() &#123; console.log(this); &#125; &#125;; &#125; 上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用RequireJs的好处]]></title>
    <url>%2F2017%2F10%2F31%2FRequireJs%2F</url>
    <content type="text"><![CDATA[一、使用RequireJs的好处 最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。 &lt;script type=&quot;text/javascript&quot; src=&quot;./js/a.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/b.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/c.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/d.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/e.js&quot;&gt;&lt;/script&gt; 这些js文件都是按照顺序从上到下依次同步加载的。 这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的a.js要在b.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。 RequireJs很好的解决了两个问题及其优势： 1、实现js文件的异步加载，避免网页失去响应； 2、管理模块之间的依赖性，便于代码的编写和维护。 3、基于AMD模块化机制，让前端代码也能实现模块化。查看《CommonJS和AMD/CMD区别详解》。 开始今天的学习之前，首先需要准备4个文件，分别是【jQuery库】、【require库】、【bootstrap库】、【require加载css插件】，大家可以点击下面的链接进行下载： 1、jquery.js 2、require.js 3、bootstrap.min.js 4、require.css.js 二、如何使用RequireJs？ 1、在html页面中引入require库，如下： &lt;script type=&quot;text/javascript&quot; src=&quot;./js/require.js&quot;&gt;&lt;/script&gt; 2、加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了： &lt;script src=&quot;js/require.js&quot; data-main=&quot;./js/main&quot;&gt;&lt;/script&gt; data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main（data-main引入的main.js文件是异步加载的，所以在加载这个文件的同时也会加载其他js文件，其他文件要依赖这个main.js，所以可以将以上代码分开来写）。 &lt;script type=&quot;text/javascript&quot; src=&quot;./js/require.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./js/main.js&quot;&gt;&lt;/script&gt; 3、主模块main.js的写法： 主模块main.js主要是加载requireJs的配置项，所以需要先了解一下这些配置项的意思： （1）baseUrl：模块默认加载路径； （2）paths：自定义模块加载路径； （3）shim：定义模块之间的依赖关系。 下面具体来看下，这是我的目录结构： require.config({ &apos;baseUrl&apos; : &apos;./app/&apos;, &apos;paths&apos; : { &apos;jquery&apos; : &apos;../js/jquery&apos;,//只写文件名，不用带后缀 }, }); html页面调用： require([&apos;jquery&apos;], function(a){ console.log(a);//functionn() });]]></content>
      <categories>
        <category>JS工具</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>项目优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel使用]]></title>
    <url>%2F2017%2F10%2F22%2Fbabel%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[babel-handbook 介绍Babel 是一个通用的多用途 JavaScript 编译器。通过 Babel 你可以使用（并创建）下一代的 JavaScript，以及下一代的 JavaScript 工具。作为一种语言，JavaScript 在不断发展，新的标准／提案和新的特性层出不穷。 在得到广泛普及之前，Babel 能够让你提前（甚至数年）使用它们。 Babel 把用最新标准编写的 JavaScript 代码向下编译成可以在今天随处可用的版本。 这一过程叫做“源码到源码”编译， 也被称为转换编译（transpiling，是一个自造合成词，即转换＋编译。以下也简称为转译）。 安装 Babel由于 JavaScript 社区没有统一的构建工具、框架、平台等等，因此 Babel 正式集成了对所有主流工具的支持。 从 Gulp 到 Browserify，从 Ember 到 Meteor，不管你的环境设置如何，Babel 都有正式的集成支持。 本手册的目的主要是介绍 Babel 内建方式的安装，不过你可以访问交互式的安装页面来查看其它的整合方式。 babel-cliBabel 的 CLI 是一种在命令行下使用 Babel 编译文件的简单方法。 让我们先全局安装它来学习基础知识。 1$ npm install --global babel-cli 我们可以这样编译我们的第一个文件 1$ babel my-file.js 这将把编译后的结果直接输出至终端。使用 --out-file 或着 -o 可以将结果写入到指定的文件。 123$ babel example.js --out-file compiled.js# 或$ babel example.js -o compiled.js 如果我们想要把一个目录整个编译成一个新的目录，可以使用 --out-dir 或者 -d。 123$ babel src --out-dir lib# 或$ babel src -d lib 在项目内运行 Babel CLI尽管你可以把 Babel CLI 全局安装在你的机器上，但是按项目逐个安装在本地会更好。 有两个主要的原因。 在同一台机器上的不同项目或许会依赖不同版本的 Babel 并允许你有选择的更新。 这意味着你对工作环境没有隐式依赖，这让你的项目有很好的可移植性并且易于安装。 要在（项目）本地安装 Babel CLI 可以运行： 1$ npm install --save-dev babel-cli 注意: 因为全局运行 Babel 通常不是什么好习惯所以如果你想要卸载全局安装的 Babel 的话，可以运行： 1$ npm uninstall --global babel-cli 安装完成后，你的 package.json 应该如下所示： 1234567&#123; "name": "my-project", "version": "1.0.0", "devDependencies": &#123; "babel-cli": "^6.0.0" &#125;&#125; 现在，我们不直接从命令行运行 Babel 了，取而代之我们将把运行命令写在 npm scripts 里，这样可以使用 Babel 的本地版本。 只需将 &quot;scripts&quot; 字段添加到你的 package.json 文件内并且把 babel 命令写成 build 字段。. 12345678910 &#123; "name": "my-project", "version": "1.0.0",+ "scripts": &#123;+ "build": "babel src -d lib"+ &#125;, "devDependencies": &#123; "babel-cli": "^6.0.0" &#125; &#125; 现在可以在终端里运行： 1npm run build 这将以与之前同样的方式运行 Babel，但这一次我们使用的是本地副本。 babel-register下一个常用的运行 Babel 的方法是通过 babel-register。这种方法只需要引入文件就可以运行 Babel，或许能更好地融入你的项目设置。 但请注意这种方法并不适合正式产品环境使用。 直接部署用此方式编译的代码不是好的做法。 在部署之前预先编译会更好。 不过用在构建脚本或是其他本地运行的脚本中是非常合适的。 让我们先在项目中创建 index.js 文件。 1console.log("Hello world") 如果我们用 node index.js 来运行它是不会使用 Babel 来编译的。所以我们需要设置 babel-register。. 首先安装 babel-register。 1$ npm install --save-dev babel-register 接着，在项目中创建 register.js 文件并添加如下代码： 12require("babel-register");require("./index.js"); 这样做可以把 Babel 注册到 Node 的模块系统中并开始编译其中 require 的所有文件。 现在我们可以使用 register.js 来代替 node index.js 来运行了。 1$ node register.js 注意：你不能在你要编译的文件内同时注册 Babel，因为 node 会在 Babel 编译它之前就将它执行了。 123require("babel-register");// 未编译的：console.log("Hello world!"); babel-node如果你要用 node CLI 来运行代码，那么整合 Babel 最简单的方式就是使用 babel-node CLI，它是 node CLI 的替代品。 但请注意这种方法并不适合正式产品环境使用。 直接部署用此方式编译的代码不是好的做法。 在部署之前预先编译会更好。 不过用在构建脚本或是其他本地运行的脚本中是非常合适的。 首先确保 babel-cli 已经安装了。 1$ npm install --save-dev babel-cli 然后用babel-node 来替代node运行所有的代码。 如果用 npm script 的话只需要这样做： 123456 &#123; "scripts": &#123;- "script-name": "node script.js"+ "script-name": "babel-node script.js" &#125; &#125; 要不然的话你需要写全 babel-node 的路径。 12- node script.js+ ./node_modules/.bin/babel-node script.js 提示：你可以使用 npm-run babel-core如果你需要以编程的方式来使用 Babel，可以使用 babel-core 这个包。 首先安装 babel-core。 1$ npm install babel-core 1var babel = require("babel-core"); 字符串形式的 JavaScript 代码可以直接使用 babel.transform 来编译。 12babel.transform("code();", options);// =&gt; &#123; code, map, ast &#125; 如果是文件的话，可以使用异步 api： 123babel.transformFile("filename.js", options, function(err, result) &#123; result; // =&gt; &#123; code, map, ast &#125;&#125;); 或者是同步 api： 12babel.transformFileSync("filename.js", options);// =&gt; &#123; code, map, ast &#125; 要是已经有一个 Babel AST（抽象语法树）了就可以直接从 AST 进行转换。 12babel.transformFromAst(ast, code, options);// =&gt; &#123; code, map, ast &#125; 对于上述所有方法，options 指的都是 http://babeljs.io/docs/usage/options/ 配置 Babel你或许已经注意到了，目前为止通过运行 Babel 自己我们并没能“翻译”代码，而仅仅是把代码从一处拷贝到了另一处。 这是因为我们还没告诉 Babel 要做什么。 由于 Babel 是一个可以用各种花样去使用的通用编译器，因此默认情况下它反而什么都不做。你必须明确地告诉 Babel 应该要做什么。 你可以通过安装插件（plugins）或预设（presets，也就是一组插件）来指示 Babel 去做什么事情。 .babelrc在我们告诉 Babel 该做什么之前，我们需要创建一个配置文件。你需要做的就是在项目的根路径下创建 .babelrc 文件。然后输入以下内容作为开始： 1234&#123; "presets": [], "plugins": []&#125; 这个文件就是用来告诉Babel做你要他做的事情的配置文件。 注意:尽管你也可以用其他方式给 Babel 传递选项，但 .babelrc 文件是约定也是最好的方式。 babel-preset-es2015我们先从让 Babel 把 ES2015（最新版本的 JavaScript 标准，也叫做 ES6）编译成 ES5（现今在大多数 JavaScript 环境下可用的版本）开始吧。 我们需要安装 “es2015” Babel 预设： 1$ npm install --save-dev babel-preset-es2015 我们修改 .babelrc 来包含这个预设。 123456 &#123; "presets": [+ "es2015" ], "plugins": [] &#125; babel-preset-stage-xJavaScript 还有一些提案，正在积极通过 TC39（ECMAScript 标准背后的技术委员会）的流程成为标准的一部分。 这个流程分为 5（0－4）个阶段。 随着提案得到越多的关注就越有可能被标准采纳，于是他们就继续通过各个阶段，最终在阶段 4 被标准正式采纳。 以下是4 个不同阶段的（打包的）预设： babel-preset-stage-0 babel-preset-stage-1 babel-preset-stage-2 babel-preset-stage-3 注意 stage-4 预设是不存在的因为它就是上面的 es2015 预设。 以上每种预设都依赖于紧随的后期阶段预设。例如，babel-preset-stage-1 依赖 babel-preset-stage-2，后者又依赖 babel-preset-stage-3。. 使用的时候只需要安装你想要的阶段就可以了： 1$ npm install --save-dev babel-preset-stage-2 然后添加进你的 .babelrc 配置文件。 1234567 &#123; "presets": [ "es2015",+ "stage-2" ], "plugins": [] &#125; 执行 Babel 生成的代码即便你已经用 Babel 编译了你的代码，但这还不算完。 babel-polyfillBabel 几乎可以编译所有时新的 JavaScript 语法，但对于 APIs 来说却并非如此。 比方说，下列含有箭头函数的需要编译的代码： 123function addAll() &#123; return Array.from(arguments).reduce((a, b) =&gt; a + b);&#125; 最终会变成这样： 12345function addAll() &#123; return Array.from(arguments).reduce(function(a, b) &#123; return a + b; &#125;);&#125; 然而，它依然无法随处可用因为不是所有的 JavaScript 环境都支持 Array.from。 Uncaught TypeError: Array.from is not a function 为了解决这个问题，我们使用一种叫做 Polyfill（代码填充，也可译作兼容性补丁） 的技术。 简单地说，polyfill 即是在当前运行环境中用来复制（意指模拟性的复制，而不是拷贝）尚不存在的原生 api 的代码。 能让你提前使用还不可用的 APIs，Array.from 就是一个例子。 Babel 用了优秀的 core-js 用作 polyfill，并且还有定制化的 regenerator 来让 generators（生成器）和 async functions（异步函数）正常工作。 要使用 Babel polyfill，首先用 npm 安装它： 1$ npm install --save babel-polyfill 然后只需要在文件顶部导入 polyfill 就可以了： 1import "babel-polyfill"; babel-runtime为了实现 ECMAScript 规范的细节，Babel 会使用“助手”方法来保持生成代码的整洁。 由于这些助手方法可能会特别长并且会被添加到每一个文件的顶部，因此你可以把它们统一移动到一个单一的“运行时（runtime）”中去。 通过安装 babel-plugin-transform-runtime 和 babel-runtime 来开始。 12$ npm install --save-dev babel-plugin-transform-runtime$ npm install --save babel-runtime 然后更新 .babelrc： 123456 &#123; "plugins": [+ "transform-runtime", "transform-es2015-classes" ] &#125; 现在，Babel 会把这样的代码： 123class Foo &#123; method() &#123;&#125;&#125; 编译成： 123456789101112131415import _classCallCheck from "babel-runtime/helpers/classCallCheck";import _createClass from "babel-runtime/helpers/createClass";let Foo = function () &#123; function Foo() &#123; _classCallCheck(this, Foo); &#125; _createClass(Foo, [&#123; key: "method", value: function method() &#123;&#125; &#125;]); return Foo;&#125;(); 这样就不需要把 _classCallCheck 和 _createClass 这两个助手方法放进每一个需要的文件里去了。 配置 Babel（进阶）大多数人使用 Babel 的内建预设就足够了，不过 Babel 提供了更多更细粒度的能力。]]></content>
      <categories>
        <category>babel</category>
      </categories>
      <tags>
        <tag>JS模块</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-music目录及样式初始化]]></title>
    <url>%2F2017%2F10%2F12%2Fvue-music%E7%9B%AE%E5%BD%95%E5%8F%8A%E6%A0%B7%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[目录初始化常用目录 api base common fonts image js stylus components router store actions getters index mutation-types mutations state api放置后端获取数据的js文件，常用方式有jsonp/axios。 jsonp的github axios的githubbase存放常用的可复用的基础componentcommon存放网页所需字体，图片，复用的js文件，和css样式文件。其中需要注意stylus文件引用顺序123@import &quot;./reset.styl&quot;@import &quot;./base.styl&quot;@import &quot;./icon.styl&quot; components存放网页所需component router存放网页路由文件 store存放网页vuex的共享数据 eslint常用配置eslint规则可以在官网查询配置相关规则12345678910&apos;rules&apos;: &#123; // allow paren-less arrow functions &apos;arrow-parens&apos;: 0, // allow async-await &apos;generator-star-spacing&apos;: 0, // allow debugger during development &apos;no-debugger&apos;: process.env.NODE_ENV === &apos;production&apos; ? 2 : 0, &apos;eol-last&apos;: 0, &apos;space-before-function-paren&apos;: 0 &#125; eslint规则的等级有三种: “off” 或者 0：关闭规则。 “warn” 或者 1：打开规则，并且作为一个警告（不影响exit code）。 “error” 或者 2：打开规则，并且作为一个错误（exit code将会是1）。 我们所配置的rules: arrow-parens: 要求箭头函数的参数使用圆括号 generator-star-spacing: 强制 generator 函数中 * 号周围使用一致的空格 no-debugger: 禁用debugger eol-last: 要求或禁止文件末尾存在空行 space-before-function-paren: 强制在 function的左括号之前使用一致的空格 webpack.base.conf 配置引用别名配置别名，项目中引用不用添加src了。 12345678910resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;@&apos;: resolve(&apos;src&apos;), &apos;common&apos;: resolve(&apos;src/common&apos;), &apos;components&apos;: resolve(&apos;src/components&apos;), &apos;base&apos;: resolve(&apos;src/base&apos;), &apos;api&apos;: resolve(&apos;src/api&apos;) &#125; &#125;,]]></content>
      <categories>
        <category>vue-items</category>
      </categories>
      <tags>
        <tag>vue-music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli(configJS)]]></title>
    <url>%2F2017%2F08%2F11%2Fvue-cli-configJS%2F</url>
    <content type="text"><![CDATA[1、此配置文件是用来定义开发环境和生产环境中所需要的参数2、关于注释，当涉及到较复杂的解释我将通过标识的方式(如（1）)将解释写到单独的注释模块，请自行查看3、上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// see http://vuejs-templates.github.io/webpack for documentation.// path是node.js的路径模块，用来处理路径统一的问题var path = require(&apos;path&apos;)module.exports = &#123; // 下面是build也就是生产编译环境下的一些配置 build: &#123; // 导入prod.env.js配置文件，只要用来指定当前环境，详细见(1) env: require(&apos;./prod.env&apos;), // 下面是相对路径的拼接，假如当前跟目录是config，那么下面配置的index属性的属性值就是dist/index.html index: path.resolve(__dirname, &apos;../dist/index.html&apos;), // 下面定义的是静态资源的根目录 也就是dist目录 assetsRoot: path.resolve(__dirname, &apos;../dist&apos;), // 下面定义的是静态资源根目录的子目录static，也就是dist目录下面的static assetsSubDirectory: &apos;static&apos;, // 下面定义的是静态资源的公开路径，也就是真正的引用路径 assetsPublicPath: &apos;/&apos;, // 下面定义是否生成生产环境的sourcmap，sourcmap是用来debug编译后文件的，通过映射到编译前文件来实现 productionSourceMap: true, // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin // 下面是是否在生产环境中压缩代码，如果要压缩必须安装compression-webpack-plugin productionGzip: false, // 下面定义要压缩哪些类型的文件 productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;], // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off // 下面是用来开启编译完成后的报告，可以通过设置值为true和false来开启或关闭 // 下面的process.env.npm_config_report表示定义的一个npm_config_report环境变量，可以自行设置 bundleAnalyzerReport: process.env.npm_config_report &#125;, dev: &#123; // 引入当前目录下的dev.env.js，用来指明开发环境，详见(2) env: require(&apos;./dev.env&apos;), // 下面是dev-server的端口号，可以自行更改 port: 8080, // 下面表示是否自定代开浏览器 autoOpenBrowser: true, assetsSubDirectory: &apos;static&apos;, assetsPublicPath: &apos;/&apos;, // 下面是代理表，作用是用来，建一个虚拟api服务器用来代理本机的请求，只能用于开发模式 // 详见(3) proxyTable: &#123;&#125;, // CSS Sourcemaps off by default because relative paths are &quot;buggy&quot; // with this option, according to the CSS-Loader README // (https://github.com/webpack/css-loader#sourcemaps) // In our experience, they generally work as expected, // just be aware of this issue when enabling this option. // 是否生成css，map文件，上面这段英文就是说使用这个cssmap可能存在问题，但是按照经验，问题不大，可以使用 // 给人觉得没必要用这个，css出了问题，直接控制台不就完事了 cssSourceMap: false &#125;&#125; 注释12345678910111213141516171819202122232425(1)下面是prod.env.js的配置内容 module.exports = &#123; // 作用很明显，就是导出一个对象，NODE_ENV是一个环境变量，指定production环境 NODE_ENV: &apos;&quot;production&quot;&apos; &#125;(2)下面是dev.env.js的配置内容 // 首先引入的是webpack的merge插件，该插件是用来合并对象，也就是配置文件用的，相同的选项会被覆盖，至于这里为什么多次一举，可能另有他图吧 var merge = require(&apos;webpack-merge&apos;) // 导入prod.env.js配置文件 var prodEnv = require(&apos;./prod.env&apos;) // 将两个配置对象合并，最终结果是 NODE_ENV: &apos;&quot;development&quot;&apos; module.exports = merge(prodEnv, &#123; NODE_ENV: &apos;&quot;development&quot;&apos; &#125;)(3)下面是proxyTable的一般用法 vue-cli使用这个功能是借助http-proxy-middleware插件，一般解决跨域请求api proxyTable: &#123; &apos;/list&apos;: &#123; target: &apos;http://api.xxxxxxxx.com&apos;, -&gt; 目标url地址 changeOrigin: true, -&gt; 指示是否跨域 pathRewrite: &#123; &apos;^/list&apos;: &apos;/list&apos; -&gt; 可以使用 /list 等价于 api.xxxxxxxx.com/list &#125; &#125; &#125;]]></content>
      <categories>
        <category>JS工具</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>config.js配置参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transform/transtion/animation]]></title>
    <url>%2F2017%2F02%2F06%2Fposttransform-transtion-animation%2F</url>
    <content type="text"><![CDATA[fransform在CSS3中transform主要包括以下几种：旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix。一起来看看CSS3中transform的旋转rotate、扭曲skew、缩放scale和移动translate具体如何实现，从transform的语法开始吧。是构成transtion和animation的基础。 语法 1transform: rotate | scale | skew | translate |matrix; 一、旋转rotate retate(value):通过指定的角度参数对原元素指定一个2D rotation(2D旋转)，需先有transform-origin属性的定义。transform-origin定义的是旋转点的基点，其中value是指旋转的角度，如果设置的值为正数表示顺时针，反之逆时针； 1transform:rolate(30deg); 二、移动translate(x,y) 移动tranlate(x,y),x水平和y垂直移动； translate(x,y):通过矢量(x,y)指定一个2D translation，x是第一个过渡值参数，y是第二个过渡值参数,如果 未被提供，则y以 0 作为其值。按照设定的x,y参数值,当值为负数时，反方向移动物 体，其基点默认为元素 中心点，也可以根据transform-origin进行改变基点。如 1transform:translate(100px,20px) 三、缩放scale(value,value) 缩放scale和移动translate是极其相似，也具有三种情况：scale(x,y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）；scaleX(x)元素仅水平方向缩放（X轴缩放）；scaleY(y)元素仅垂直方向缩放（Y轴缩放），但它们具有相同的缩放中心点和基数，其中心点就是元素的中心位置，缩放基数为1，如果其值大于1元素就放大，反之其值小于1，元素缩小。下面我们具体来看看这三种情况具体使用方法： 123transform:scale(2,1.5)transform:scaleX(2)transform:scaleY(1.5) 四、扭曲skew 第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则值为0，也就是Y轴方向上无斜切。skew是用来对元素进行扭曲变行，第一个参数是水平方向扭曲角度，第二个参数是垂直方向扭曲角度。其中第二个参数是可选参数，如果没有设置第二个参数，那么Y轴为0deg。同样是以元素中心为基点，我们也可以通过transform-origin来改变元素的基点位置。 1transform:skew(30deg,10deg); transition一、transition-property transition-property是用来指定当元素其中一个属性改变时执行transition效果，其主要有以下几个值：none(没有属性改变)；all（所有属性改变）这个也是其默认值；indent（元素属性名）。当其值为none时，transition马上停止执行，当指定为all时，则元素产生任何属性值变化时都将执行transition效果，ident是可以指定元素的某一个属性值。 12345678910111213141516171819202122232425color: 通过红、绿、蓝和透明度组件变换（每个数值处理）如：background-color,border-color,color,outline-color等css属性；length: 真实的数字 如：word-spacing,width,vertical-align,top,right,bottom,left,padding,outline-width,margin,min-width,min-height,max-width,max-height,line-height,height,border-width,border-spacing,background-position等属性；percentage:真实的数字 如：word-spacing,width,vertical-align,top,right,bottom,left,min-width,min-height,max-width,max-height,line-height,height,background-position等属性；integer离散步骤（整个数字），在真实的数字空间，以及使用floor()转换为整数时发生 如：outline-offset,z-index等属性；number真实的（浮点型）数值，如：zoom,opacity,font-weight,等属性；transform list:详情请参阅：《CSS3 Transform》rectangle:通过x, y, width 和 height（转为数值）变换，如：cropvisibility: 离散步骤，在0到1数字范围之内，0表示“隐藏”，1表示完全“显示”,如：visibilityshadow: 作用于color, x, y 和 blur（模糊）属性,如：text-shadowgradient: 通过每次停止时的位置和颜色进行变化。它们必须有相同的类型（放射状的或是线性的）和相同的停止数值以便执行动画,如：background-imagepaint server (SVG): 只支持下面的情况：从gradient到gradient以及color到color，然后工作与上面类似space-separated list of above:如果列表有相同的项目数值，则列表每一项按照上面的规则进行变化，否则无变化a shorthand property: 如果缩写的所有部分都可以实现动画，则会像所有单个属性变化一样变化 二、transition-duration 语法： 1transition-duration:time 如(transition-duration: 2.2s;) 三、transition-timing-function 语法： 1transition-timing-function:ease | linear | ease-in | ease-out | ease-in-out | 取值： 1234567891011121314transition-timing-function的值允许你根据时间的推进去改变属性值的变换速率，transition-timing-function有6个可能值：ease：（逐渐变慢）默认值，ease函数等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0).linear：（匀速），linear 函数等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0).ease-in：(加速)，ease-in 函数等同于贝塞尔曲线(0.42, 0, 1.0, 1.0).ease-out：（减速），ease-out 函数等同于贝塞尔曲线(0, 0, 0.58, 1.0).ease-in-out：（加速然后减速），ease-in-out 函数等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)cubic-bezier：（该值允许你去自定义一个时间曲线）， 特定的cubic-bezier曲线。 (x1, y1, x2, y2)四个值特定于曲线上点P1和点P2。所有值需在[0, 1]区域内，否则无效。如（cubic-bezier(0.94,-0.1, 0.29, 1.2)）]]></content>
      <categories>
        <category>css3动画属性</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>动画</tag>
      </tags>
  </entry>
</search>
